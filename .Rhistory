pop_data <- data.frame(x1, x2, y, pr)
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 10000
results <- matrix(0, n_reps, 3)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
xs = model.matrix(~x1 + x2, sample)
zs = model.matrix(~x1 + y, sample)
d = rep(1, NROW(sample))
## generalized calibration
g_generl <-gencal(totals = totals,nonresponse = xs, instrumental_variables=zs, target_variables=y,initial_weights=d)
## naive
results[r,1] <- mean(sample$y)
results[r,2] <- weighted.mean(sample$y, g_standard)
results[r,3] <- weighted.mean(sample$y, g_generl)
}
library(sampling)
gencal <-  function(totals, nonresponse, instrumental_variables = NULL, target_variables, initial_weights) {
weights <- gencalib(nonresponse,
instrumental_variables,
initial_weights,
total = totals,
method = "raking")
return(weights)
}
set.seed(123)
n <- 10000
x1 <- rlnorm(n, 0, 1)
x2 <- rexp(n, 1)
y <- 1 + x1 + x2 + rnorm(n)
pr <- plogis(1 + 0.5*x1 - 0.5*y)
pop_data <- data.frame(x1, x2, y, pr)
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 10000
results <- matrix(0, n_reps, 3)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
xs = model.matrix(~x1 + x2, sample)
zs = model.matrix(~x1 + y, sample)
d = rep(1, NROW(sample))
## generalized calibration
g_generl <-gencal(totals = totals,nonresponse = xs, instrumental_variables=zs, target_variables=y,initial_weights=d)
## naive
results[r,1] <- mean(sample$y)
results[r,2] <- weighted.mean(sample$y, g_standard)
results[r,3] <- weighted.mean(sample$y, g_generl)
}
rm(list = ls())
library(sampling)
gencal <-  function(totals, nonresponse, instrumental_variables = NULL, target_variables, initial_weights) {
weights <- gencalib(nonresponse,
instrumental_variables,
initial_weights,
total = totals,
method = "raking")
return(weights)
}
### testing
set.seed(123)
n <- 10000
x1 <- rlnorm(n, 0, 1)
x2 <- rexp(n, 1)
y <- 1 + x1 + x2 + rnorm(n)
pr <- plogis(1 + 0.5*x1 - 0.5*y)
pop_data <- data.frame(x1, x2, y, pr)
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 10000
results <- matrix(0, n_reps, 3)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
xs = model.matrix(~x1 + x2, sample)
zs = model.matrix(~x1 + y, sample)
d = rep(1, NROW(sample))
## generalized calibration
g_generl <-gencal(totals = totals,nonresponse = xs, instrumental_variables=zs, target_variables=y,initial_weights=d)
## naive
results[r,1] <- mean(sample$y)
results[r,2] <- weighted.mean(sample$y, g_standard)
results[r,3] <- weighted.mean(sample$y, g_generl)
}
library(sampling)
gencal <-  function(totals, nonresponse, instrumental_variables = NULL, target_variables, initial_weights) {
weights <- gencalib(nonresponse,
instrumental_variables,
initial_weights,
total = totals,
method = "raking")
return(weights)
}
### testing
set.seed(123)
n <- 10000
x1 <- rlnorm(n, 0, 1)
x2 <- rexp(n, 1)
y <- 1 + x1 + x2 + rnorm(n)
pr <- plogis(1 + 0.5*x1 - 0.5*y)
pop_data <- data.frame(x1, x2, y, pr)
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 10000
results <- matrix(0, n_reps, 2)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
xs = model.matrix(~x1 + x2, sample)
zs = model.matrix(~x1 + y, sample)
d = rep(1, NROW(sample))
## generalized calibration
g_generl <-gencal(totals = totals,nonresponse = xs, instrumental_variables=zs, target_variables=y,initial_weights=d)
## naive
results[r,1] <- mean(sample$y)
results[r,2] <- weighted.mean(sample$y, g_generl)
}
boxplot(results - mean(pop_data$y))
abline(h = 0, col = "red")
y_true <- pop_data$y
apply(results, 2, FUN = function(x) c(bias = mean(x) - mean(y_true),
sd = sd(x),
rmse = sqrt( (mean(x) - mean(y_true))^2 + var(x))))
library(sampling)
gencal <-  function(totals, nonresponse, instrumental_variables = NULL, target_variables, initial_weights) {
if (dim(nonresponse) == dim(instrumental_variables)){
weights <- gencalib(nonresponse,
instrumental_variables,
initial_weights,
total = totals,
method = "raking")
return(weights)}
}
### testing
set.seed(123)
n <- 10000
x1 <- rlnorm(n, 0, 1)
x2 <- rexp(n, 1)
y <- 1 + x1 + x2 + rnorm(n)
pr <- plogis(1 + 0.5*x1 - 0.5*y)
pop_data <- data.frame(x1, x2, y, pr)
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 10000
results <- matrix(0, n_reps, 2)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
xs = model.matrix(~x1 + x2, sample)
zs = model.matrix(~x1 + y, sample)
d = rep(1, NROW(sample))
## generalized calibration
g_generl <-gencal(totals = totals,nonresponse = xs, instrumental_variables=zs, target_variables=y,initial_weights=d)
## naive
results[r,1] <- mean(sample$y)
results[r,2] <- weighted.mean(sample$y, g_generl)
}
dim(xs)
dim(zs)
dim(xs) == dim(zs)
sum(dim(xs) == dim(zs))
len(xs)
length(xs)
nrow(xd)
nrow(xd)
nrow(xs)
ncol(xs)
xs
library(sampling)
gencal <-  function(totals, nonresponse, instrumental_variables = NULL, target_variables, initial_weights) {
if (sum(dim(nonresponse) == dim(instrumental_variables)) == ncol(nonresponse) -1) {
weights <- gencalib(nonresponse,
instrumental_variables,
initial_weights,
total = totals,
method = "raking")
return(weights)}
}
### testing
set.seed(123)
n <- 10000
x1 <- rlnorm(n, 0, 1)
x2 <- rexp(n, 1)
y <- 1 + x1 + x2 + rnorm(n)
pr <- plogis(1 + 0.5*x1 - 0.5*y)
pop_data <- data.frame(x1, x2, y, pr)
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 10000
results <- matrix(0, n_reps, 2)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
xs = model.matrix(~x1 + x2, sample)
zs = model.matrix(~x1 + y, sample)
d = rep(1, NROW(sample))
## generalized calibration
g_generl <-gencal(totals = totals,nonresponse = xs, instrumental_variables=zs, target_variables=y,initial_weights=d)
## naive
results[r,1] <- mean(sample$y)
results[r,2] <- weighted.mean(sample$y, g_generl)
}
boxplot(results - mean(pop_data$y))
abline(h = 0, col = "red")
y_true <- pop_data$y
apply(results, 2, FUN = function(x) c(bias = mean(x) - mean(y_true),
sd = sd(x),
rmse = sqrt( (mean(x) - mean(y_true))^2 + var(x))))
library(sampling)
library(devtools)
library(rstudioapi)
source("gencalib.R")
library(sampling)
library(devtools)
library(rstudioapi)
source("R/gencalib.R")
mnar <- function(totals, calib_var, instr_var = NULL, target_var, initial_weights, method) {
if (method == "gencalib") {
weights <- gencal(totals, calib_var, instr_var, target_var, initial_weights)
return(weights)
} else {
stop("Unknown method specified")
}
}
library(sampling)
library(rstudioapi)
setwd(dirname(getActiveDocumentContext()$path))
load_all()
set.seed(123)
n <- 10000
x1 <- rlnorm(n, 0, 1)
x2 <- rexp(n, 1)
y <- 1 + x1 + x2 + rnorm(n)
pr <- plogis(1 + 0.5*x1 - 0.5*y)
pop_data <- data.frame(x1, x2, y, pr)
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 10000
results <- matrix(0, n_reps, 2)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
xs = model.matrix(~x1 + x2, sample)
zs = model.matrix(~x1 + y, sample)
d = rep(1, NROW(sample))
## generalized calibration
g_generl <-mnar(totals = totals,calib_var = xs, instr_var=zs, target_var=y,initial_weights=d, method = "gencalib")
## naive
results[r,1] <- mean(sample$y)
results[r,2] <- weighted.mean(sample$y, g_generl)
}
boxplot(results - mean(pop_data$y))
abline(h = 0, col = "red")
y_true <- pop_data$y
apply(results, 2, FUN = function(x) c(bias = mean(x) - mean(y_true),
sd = sd(x),
rmse = sqrt( (mean(x) - mean(y_true))^2 + var(x))))
library(sampling)
library(rstudioapi)
load_all()
set.seed(123)
n <- 10000
x1 <- rlnorm(n, 0, 1)
x2 <- rexp(n, 1)
y <- 1 + x1 + x2 + rnorm(n)
pr <- plogis(1 + 0.5*x1 - 0.5*y)
pop_data <- data.frame(x1, x2, y, pr)
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 10000
results <- matrix(0, n_reps, 2)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
xs = model.matrix(~x1 + x2, sample)
zs = model.matrix(~x1 + y, sample)
d = rep(1, NROW(sample))
## generalized calibration
g_generl <-mnar(totals = totals,calib_var = xs, instr_var=zs, target_var=y,initial_weights=d, method = "gencalib")
## naive
results[r,1] <- mean(sample$y)
results[r,2] <- weighted.mean(sample$y, g_generl)
}
boxplot(results - mean(pop_data$y))
abline(h = 0, col = "red")
y_true <- pop_data$y
apply(results, 2, FUN = function(x) c(bias = mean(x) - mean(y_true),
sd = sd(x),
rmse = sqrt( (mean(x) - mean(y_true))^2 + var(x))))
check()
check()
install.packages("MASS")
check()
library(sampling)
library(devtools)
library(rstudioapi)
check()
library(MASS)
check()
install.packages("~/projects/mnar.tar.gz", repos = NULL, type = "source")
remove.packages("MASS")
remove.packages("sampling")
install.packages(c("MASS", "sampling"))
check()
library(sampling)
library(sampling)
library(sampling)
install.packages("sampling")
library(sampling)
library(sampling)
library(sampling)
find.package("MASS")
remove.packages("MASS")
remove.packages("sampling")
install.packages("sampling")
library(sampling)
library(devtools)
(rstudioapi)
library(sampling)
library(sampling)
library(sampling)
remove.packages("sampling")
install.packages("sampling")
library(sampling)
library(devtools)
library(rstudioapi)
library(sampling)
library(devtools)
library(rstudioapi)
load_all()
set.seed(123)
n <- 10000
x1 <- rlnorm(n, 0, 1)
x2 <- rexp(n, 1)
y <- 1 + x1 + x2 + rnorm(n)
pr <- plogis(1 + 0.5*x1 - 0.5*y)
pop_data <- data.frame(x1, x2, y, pr)
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 10000
results <- matrix(0, n_reps, 2)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
xs = model.matrix(~x1 + x2, sample)
zs = model.matrix(~x1 + y, sample)
d = rep(1, NROW(sample))
## generalized calibration
g_generl <-mnar(totals = totals,calib_var = xs, instr_var=zs, target_var=y,initial_weights=d, method = "gencalib")
## naive
results[r,1] <- mean(sample$y)
results[r,2] <- weighted.mean(sample$y, g_generl)
}
boxplot(results - mean(pop_data$y))
abline(h = 0, col = "red")
y_true <- pop_data$y
apply(results, 2, FUN = function(x) c(bias = mean(x) - mean(y_true),
sd = sd(x),
rmse = sqrt( (mean(x) - mean(y_true))^2 + var(x))))
check()
update.packages(ask = FALSE, checkBuilt = TRUE)
check()
find.package("nazwa_pakietu")
find.package("sampling")
find.package("MASS")
find.package("rstudioapi")
.libPaths()
install.packages("mnar")
.libPaths()
library_paths <- .libPaths()
# Iteracja po każdej ścieżce
for (path in library_paths) {
cat("Sprawdzanie ścieżki:", path, "\n")
# Możesz sprawdzić, jakie pakiety są zainstalowane w danej ścieżce
installed_packages <- list.files(path)
# Wyświetl zainstalowane pakiety w tej ścieżce
cat("Pakiety zainstalowane w tej ścieżce:\n")
print(installed_packages)
cat("\n\n")
}
check()
library(sampling)
library(devtools)
library(rstudioapi)
check()
lib.loc()
loadNamespace(i, c(lib.loc, .libPaths()), versionCheck = vI[[i]])
for (path in library_paths) {
loadNamespace(path, c(lib.loc, .libPaths()), versionCheck = vI[[path]])
}
packageVersion("MASS")
library(MASS)
find.package("MASS")
library(MASS, lib.loc = .libPaths())
library(MASS, lib.loc = .libPaths())
ls -l "/Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/MASS"
remove.packages("MASS")
install.packages("MASS")
library(sampling)
library(devtools)
library(rstudioapi)
load_all()
check()
# Nazwa pakietu
i <- "MASS"
# Ścieżki bibliotek (możesz użyć .libPaths() lub konkretnej ścieżki)
lib.loc <- NULL
# Domyślne ścieżki w R
lib_paths <- .libPaths()
# Przykładowa lista z wymaganymi wersjami (opcjonalnie)
vI <- list(MASS = "7.3-54.4") # lub NULL, jeśli nie chcesz wersji
# Wykonaj ręczne ładowanie przestrzeni nazw
ns <- loadNamespace(i, c(lib.loc, lib_paths), versionCheck = vI[[i]])
# Wykonaj ręczne ładowanie przestrzeni nazw
# Przykład bez sprawdzania wersji
ns <- loadNamespace(i, c(lib.loc, lib_paths), versionCheck = NULL)
ns
check()
install.packages("roxygen2", version = "7.3.1")
check()
check()
library(sampling)
library(devtools)
library(rstudioapi)
check()
install.packages("MASS", repos=c("http://rstudio.org/_packages",
"http://cran.rstudio.com",dependencies=TRUE))
library(sampling)
library(devtools)
library(rstudioapi)
check()
load_all()
set.seed(123)
n <- 10000
x1 <- rlnorm(n, 0, 1)
x2 <- rexp(n, 1)
y <- 1 + x1 + x2 + rnorm(n)
pr <- plogis(1 + 0.5*x1 - 0.5*y)
pop_data <- data.frame(x1, x2, y, pr)
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 10000
results <- matrix(0, n_reps, 2)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
xs = model.matrix(~x1 + x2, sample)
zs = model.matrix(~x1 + y, sample)
d = rep(1, NROW(sample))
## generalized calibration
g_generl <-mnar(totals = totals,calib_var = xs, instr_var=zs, target_var=y,initial_weights=d, method = "gencalib")
## naive
results[r,1] <- mean(sample$y)
results[r,2] <- weighted.mean(sample$y, g_generl)
}
boxplot(results - mean(pop_data$y))
abline(h = 0, col = "red")
y_true <- pop_data$y
apply(results, 2, FUN = function(x) c(bias = mean(x) - mean(y_true),
sd = sd(x),
rmse = sqrt( (mean(x) - mean(y_true))^2 + var(x))))
.libPaths()
# Pobierz wszystkie ścieżki z .libPaths()
library_paths <- .libPaths()
# Iteracja po każdej ścieżce
for (path in library_paths) {
cat("Sprawdzanie ścieżki:", path, "\n")
# Możesz sprawdzić, jakie pakiety są zainstalowane w danej ścieżce
installed_packages <- list.files(path)
# Wyświetl zainstalowane pakiety w tej ścieżce
cat("Pakiety zainstalowane w tej ścieżce:\n")
print(installed_packages)
cat("\n\n")
}
packageVersion("sampling")
library(sampling)
library(devtools)
library(rstudioapi)
check()
load_all()
set.seed(123)
n <- 10000
x1 <- rlnorm(n, 0, 1)
x2 <- rexp(n, 1)
y <- 1 + x1 + x2 + rnorm(n)
pr <- plogis(1 + 0.5*x1 - 0.5*y)
pop_data <- data.frame(x1, x2, y, pr)
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 10000
results <- matrix(0, n_reps, 2)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
xs = model.matrix(~x1 + x2, sample)
zs = model.matrix(~x1 + y, sample)
d = rep(1, NROW(sample))
## generalized calibration
g_generl <-mnar(totals = totals,calib_var = xs, instr_var=zs, target_var=y,initial_weights=d, method = "gencalib")
## naive
results[r,1] <- mean(sample$y)
results[r,2] <- weighted.mean(sample$y, g_generl)
}
boxplot(results - mean(pop_data$y))
abline(h = 0, col = "red")
y_true <- pop_data$y
apply(results, 2, FUN = function(x) c(bias = mean(x) - mean(y_true),
sd = sd(x),
rmse = sqrt( (mean(x) - mean(y_true))^2 + var(x))))
# Pobierz wszystkie ścieżki z .libPaths()
library_paths <- .libPaths()
# Iteracja po każdej ścieżce
for (path in library_paths) {
cat("Sprawdzanie ścieżki:", path, "\n")
# Możesz sprawdzić, jakie pakiety są zainstalowane w danej ścieżce
installed_packages <- list.files(path)
# Wyświetl zainstalowane pakiety w tej ścieżce
cat("Pakiety zainstalowane w tej ścieżce:\n")
print(installed_packages)
cat("\n\n")
}
