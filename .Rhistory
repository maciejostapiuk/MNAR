}
if (l == max_iter) {
warning("No convergence within the maximum number of iterations")
return(NULL)
} else {
g <- w1 / initial_weights
return(g)
}
}
}
set.seed(123)
n <- 10000
# Generowanie danych populacyjnych
x1 <- rlnorm(n, 0, 1)
x2 <- rexp(n, 1)
x3 <- rnorm(n, 2, 1)  # Dodatkowa zmienna, by zwiększyć wymiar Zs
y <- 1 + x1 + x2 + rnorm(n)
pr <- plogis(1 + 0.5 * x1 - 0.5 * y)
pop_data <- data.frame(x1, x2, x3, y, pr)
# Ustalanie sum kontrolnych (totals) dla Xs
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 1000  # Liczba replikacji (zmniejszona dla szybkości działania)
results <- matrix(0, n_reps, 2)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
# Xs zawiera x1 i x2 (wymiar 2)
xs <- model.matrix(~ x1 + x2, sample)
# Zs zawiera x1, x3 i y (wymiar 3)
zs <- model.matrix(~ x1 + x3 + y, sample)
d <- rep(1, NROW(sample))  # Wagi początkowe
# Skalibrowane wagi używając funkcji gencal
g_calib <- gencal(totals = totals, nonresponse = xs, calib_var = zs, target_var = y, initial_weights = d)
# Wyniki
results[r, 1] <- mean(sample$y)  # Naive
if (!is.null(g_calib)) {
results[r, 2] <- weighted.mean(sample$y, g_calib)
} else {
results[r, 2] <- NA
}
}
# Wizualizacja wyników
boxplot(results - mean(pop_data$y), names = c("Naive", "Generalized Calibration"))
abline(h = 0, col = "red")
# Obliczanie statystyk dla każdego podejścia
y_true <- pop_data$y
summary_stats <- apply(results, 2, FUN = function(x) {
bias <- mean(x, na.rm = TRUE) - mean(y_true)
sd_x <- sd(x, na.rm = TRUE)
rmse <- sqrt(bias^2 + var(x, na.rm = TRUE))
c(bias = bias, sd = sd_x, rmse = rmse)
})
print(summary_stats)
#' @title An internal function for calibration of weights to adjust for nonignorable nonresponse
#'
#' @author Maciej Ostapiuk and Maciej Beręsewicz based on Kott and Chang (2010) and Kott and Liao (2017)
#' @param totals A vector of population totals
#' @param calib_var A matrix of calibration variables
#' @param instr_var A matrix of instrumental variables
#' @param target_var A vector of target variables
#' @param initial_weights A vector of initial weights, derived from sampling design
#'
#' @importFrom sampling gencalib
gencal <- function(totals, nonresponse, calib_var = NULL, target_var = NULL, initial_weights) {
if (all(dim(nonresponse) == dim(calib_var))) {
weights <- sampling::gencalib(Xs = nonresponse,
Zs = calib_var,
d = initial_weights,
total = totals,
method = "raking")
return(weights)
} else if (all(dim(nonresponse) < dim(calib_var))) {
max_iter <- 5000
EPS <- .Machine$double.eps
EPS1 <- 1e-06
lambda <- as.matrix(rep(0, ncol(nonresponse)))
w1 <- as.vector(initial_weights * exp(calib_var %*% lambda))
T <- t(nonresponse)
Bz <- ginv(t(nonresponse * initial_weights) %*% calib_var, tol = EPS) %*% t(calib_var)
for (l in 1:max_iter) {
phi <- t(nonresponse) %*% w1 - totals[-1]
phiprim <- T %*% calib_var %*% Bz
# Aktualizacja lambda
lambda_step <- ginv(phiprim, tol = EPS) %*% phi
lambda <- lambda - lambda_step
w1 <- as.vector(initial_weights * exp(calib_var %*% lambda))
# Diagnostyka
if (any(is.na(w1)) | any(is.infinite(w1)) | any(is.nan(w1))) {
warning("No convergence: weights contain NA, NaN, or Inf values")
return(NULL)
}
tr <- crossprod(nonresponse, w1)
expression <- max(abs(tr - totals[-1]) / totals[-1])
if (any(totals[-1] == 0)) expression <- max(abs(tr - totals[-1]))
# Sprawdzenie konwergencji
if (expression < EPS1) break
}
if (l == max_iter) {
warning("No convergence within the maximum number of iterations")
return(NULL)
} else {
g <- w1 / initial_weights
return(g)
}
}
}
set.seed(123)
n <- 10000
# Generowanie danych populacyjnych
x1 <- rlnorm(n, 0, 1)
x2 <- rexp(n, 1)
x3 <- rnorm(n, 2, 1)  # Dodatkowa zmienna, by zwiększyć wymiar Zs
y <- 1 + x1 + x2 + rnorm(n)
pr <- plogis(1 + 0.5 * x1 - 0.5 * y)
pop_data <- data.frame(x1, x2, x3, y, pr)
# Ustalanie sum kontrolnych (totals) dla Xs
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 1000  # Liczba replikacji (zmniejszona dla szybkości działania)
results <- matrix(0, n_reps, 2)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
# Xs zawiera x1 i x2 (wymiar 2)
xs <- model.matrix(~ x1 + x2, sample)
# Zs zawiera x1, x3 i y (wymiar 3)
zs <- model.matrix(~ x1 + x3 + y, sample)
d <- rep(1, NROW(sample))  # Wagi początkowe
# Skalibrowane wagi używając funkcji gencal
g_calib <- gencal(totals = totals, nonresponse = xs, calib_var = zs, target_var = y, initial_weights = d)
# Wyniki
results[r, 1] <- mean(sample$y)  # Naive
if (!is.null(g_calib)) {
results[r, 2] <- weighted.mean(sample$y, g_calib)
} else {
results[r, 2] <- NA
}
}
# Wizualizacja wyników
boxplot(results - mean(pop_data$y), names = c("Naive", "Generalized Calibration"))
abline(h = 0, col = "red")
# Obliczanie statystyk dla każdego podejścia
y_true <- pop_data$y
summary_stats <- apply(results, 2, FUN = function(x) {
bias <- mean(x, na.rm = TRUE) - mean(y_true)
sd_x <- sd(x, na.rm = TRUE)
rmse <- sqrt(bias^2 + var(x, na.rm = TRUE))
c(bias = bias, sd = sd_x, rmse = rmse)
})
print(summary_stats)
rm(list = ls())
#' @title An internal function for calibration of weights to adjust for nonignorable nonresponse
#'
#' @author Maciej Ostapiuk and Maciej Beręsewicz based on Kott and Chang (2010) and Kott and Liao (2017)
#' @param totals A vector of population totals
#' @param calib_var A matrix of calibration variables
#' @param instr_var A matrix of instrumental variables
#' @param target_var A vector of target variables
#' @param initial_weights A vector of initial weights, derived from sampling design
#'
#' @importFrom sampling gencalib
gencal <- function(totals, nonresponse, calib_var = NULL, target_var = NULL, initial_weights) {
if (all(dim(nonresponse) == dim(calib_var))) {
weights <- sampling::gencalib(Xs = nonresponse,
Zs = calib_var,
d = initial_weights,
total = totals,
method = "raking")
return(weights)
} else if (all(dim(nonresponse) < dim(calib_var))) {
max_iter <- 5000
EPS <- .Machine$double.eps
EPS1 <- 1e-06
lambda <- as.matrix(rep(0, ncol(nonresponse)))
w1 <- as.vector(initial_weights * exp(calib_var %*% lambda))
T <- t(nonresponse)
Bz <- ginv(t(nonresponse * initial_weights) %*% calib_var, tol = EPS) %*% t(calib_var)
for (l in 1:max_iter) {
phi <- t(nonresponse) %*% w1 - totals[-1]
phiprim <- T %*% calib_var %*% Bz
# Aktualizacja lambda
lambda_step <- ginv(phiprim, tol = EPS) %*% phi
lambda <- lambda - lambda_step
w1 <- as.vector(initial_weights * exp(calib_var %*% lambda))
# Diagnostyka
if (any(is.na(w1)) | any(is.infinite(w1)) | any(is.nan(w1))) {
warning("No convergence: weights contain NA, NaN, or Inf values")
return(NULL)
}
tr <- crossprod(nonresponse, w1)
expression <- max(abs(tr - totals[-1]) / totals[-1])
if (any(totals[-1] == 0)) expression <- max(abs(tr - totals[-1]))
# Sprawdzenie konwergencji
if (expression < EPS1) break
}
if (l == max_iter) {
warning("No convergence within the maximum number of iterations")
return(NULL)
} else {
g <- w1 / initial_weights
return(g)
}
}
}
set.seed(123)
n <- 10000
# Generowanie danych populacyjnych
x1 <- rlnorm(n, 0, 1)
x2 <- rexp(n, 1)
x3 <- rnorm(n, 2, 1)  # Dodatkowa zmienna, by zwiększyć wymiar Zs
y <- 1 + x1 + x2 + rnorm(n)
pr <- plogis(1 + 0.5 * x1 - 0.5 * y)
pop_data <- data.frame(x1, x2, x3, y, pr)
# Ustalanie sum kontrolnych (totals) dla Xs
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 1000  # Liczba replikacji (zmniejszona dla szybkości działania)
results <- matrix(0, n_reps, 2)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
# Xs zawiera x1 i x2 (wymiar 2)
xs <- model.matrix(~ x1 + x2, sample)
# Zs zawiera x1, x3 i y (wymiar 3)
zs <- model.matrix(~ x1 + x3 + y, sample)
d <- rep(1, NROW(sample))  # Wagi początkowe
# Skalibrowane wagi używając funkcji gencal
g_calib <- gencal(totals = totals, nonresponse = xs, calib_var = zs, target_var = y, initial_weights = d)
# Wyniki
results[r, 1] <- mean(sample$y)  # Naive
if (!is.null(g_calib)) {
results[r, 2] <- weighted.mean(sample$y, g_calib)
} else {
results[r, 2] <- NA
}
}
# Wizualizacja wyników
boxplot(results - mean(pop_data$y), names = c("Naive", "Generalized Calibration"))
abline(h = 0, col = "red")
# Obliczanie statystyk dla każdego podejścia
y_true <- pop_data$y
summary_stats <- apply(results, 2, FUN = function(x) {
bias <- mean(x, na.rm = TRUE) - mean(y_true)
sd_x <- sd(x, na.rm = TRUE)
rmse <- sqrt(bias^2 + var(x, na.rm = TRUE))
c(bias = bias, sd = sd_x, rmse = rmse)
})
print(summary_stats)
#' @title An internal function for calibration of weights to adjust for nonignorable nonresponse
#'
#' @author Maciej Ostapiuk and Maciej Beręsewicz based on Kott and Chang (2010) and Kott and Liao (2017)
#' @param totals A vector of population totals
#' @param calib_var A matrix of calibration variables
#' @param instr_var A matrix of instrumental variables
#' @param target_var A vector of target variables
#' @param initial_weights A vector of initial weights, derived from sampling design
#'
#' @importFrom sampling gencalib
gencal <- function(totals, nonresponse, calib_var = NULL, target_var = NULL, initial_weights) {
if (all(dim(nonresponse) == dim(calib_var))) {
weights <- sampling::gencalib(Xs = nonresponse,
Zs = calib_var,
d = initial_weights,
total = totals,
method = "raking")
return(weights)
} else if (all(dim(nonresponse) < dim(calib_var))) {
max_iter <- 5000
EPS <- .Machine$double.eps
EPS1 <- 1e-06
lambda <- as.matrix(rep(0, ncol(nonresponse)))
w1 <- as.vector(initial_weights * exp(calib_var %*% lambda))
T <- t(nonresponse)
Bz <- ginv(t(nonresponse * initial_weights) %*% calib_var, tol = EPS) %*% t(calib_var)
for (l in 1:max_iter) {
phi <- t(nonresponse) %*% w1 - totals[-1]
phiprim <- T %*% calib_var %*% Bz
# Aktualizacja lambda
lambda_step <- ginv(phiprim, tol = EPS) %*% phi
lambda <- lambda - lambda_step
w1 <- as.vector(initial_weights * exp(calib_var %*% lambda))
# Diagnostyka
if (any(is.na(w1)) | any(is.infinite(w1)) | any(is.nan(w1))) {
warning("No convergence: weights contain NA, NaN, or Inf values")
return(NULL)
}
tr <- crossprod(nonresponse, w1)
expression <- max(abs(tr - totals[-1]) / totals[-1])
if (any(totals[-1] == 0)) expression <- max(abs(tr - totals[-1]))
# Sprawdzenie konwergencji
if (expression < EPS1) break
}
if (l == max_iter) {
warning("No convergence within the maximum number of iterations")
return(NULL)
} else {
g <- w1 / initial_weights
return(g)
}
}
}
set.seed(123)
n <- 10000
# Generowanie danych populacyjnych
x1 <- rlnorm(n, 0, 1)
x2 <- rexp(n, 1)
x3 <- rnorm(n, 2, 1)  # Dodatkowa zmienna, by zwiększyć wymiar Zs
y <- 1 + x1 + x2 + rnorm(n)
pr <- plogis(1 + 0.5 * x1 - 0.5 * y)
pop_data <- data.frame(x1, x2, x3, y, pr)
# Ustalanie sum kontrolnych (totals) dla Xs
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 1000  # Liczba replikacji (zmniejszona dla szybkości działania)
results <- matrix(0, n_reps, 2)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
# Xs zawiera x1 i x2 (wymiar 2)
xs <- model.matrix(~ x1 + x2, sample)
# Zs zawiera x1, x3 i y (wymiar 3)
zs <- model.matrix(~ x1 + x2 + y, sample)
d <- rep(1, NROW(sample))  # Wagi początkowe
# Skalibrowane wagi używając funkcji gencal
g_calib <- gencal(totals = totals, nonresponse = xs, calib_var = zs, target_var = y, initial_weights = d)
# Wyniki
results[r, 1] <- mean(sample$y)  # Naive
if (!is.null(g_calib)) {
results[r, 2] <- weighted.mean(sample$y, g_calib)
} else {
results[r, 2] <- NA
}
}
# Wizualizacja wyników
boxplot(results - mean(pop_data$y), names = c("Naive", "Generalized Calibration"))
abline(h = 0, col = "red")
# Obliczanie statystyk dla każdego podejścia
y_true <- pop_data$y
summary_stats <- apply(results, 2, FUN = function(x) {
bias <- mean(x, na.rm = TRUE) - mean(y_true)
sd_x <- sd(x, na.rm = TRUE)
rmse <- sqrt(bias^2 + var(x, na.rm = TRUE))
c(bias = bias, sd = sd_x, rmse = rmse)
})
print(summary_stats)
#' @title An internal function for calibration of weights to adjust for nonignorable nonresponse
#'
#' @author Maciej Ostapiuk and Maciej Beręsewicz based on Kott and Chang (2010) and Kott and Liao (2017)
#' @param totals A vector of population totals
#' @param calib_var A matrix of calibration variables
#' @param instr_var A matrix of instrumental variables
#' @param target_var A vector of target variables
#' @param initial_weights A vector of initial weights, derived from sampling design
#'
#' @importFrom sampling gencalib
gencal <- function(totals, nonresponse, calib_var = NULL, target_var = NULL, initial_weights) {
if (all(dim(nonresponse) == dim(calib_var))) {
weights <- sampling::gencalib(Xs = nonresponse,
Zs = calib_var,
d = initial_weights,
total = totals,
method = "raking")
return(weights)
} else if (all(dim(nonresponse) < dim(calib_var))) {
max_iter = 500
EPS = .Machine$double.eps
EPS1 = 1e-06
lambda = as.matrix(rep(0, ncol(Xs)))
w1 = as.vector(d * exp(Zs %*% lambda * q))
T = t(Xs)
Bz <- ginv(t(Xs * d * q) %*% Zs, tol = EPS) %*% t(Zs)
for (l in 1:max_iter) {
phi = t(Xs) %*% w1 - total
phiprim = T %*% Zs %*% Bz
lambda = lambda - ginv(phiprim, tol = EPS) %*% phi
w1 = as.vector(d * exp(Zs %*% lambda * q))
if (any(is.na(w1)) | any(is.infinite(w1)) | any(is.nan(w1))) {
warning("No convergence")
g = NULL
der = g
l = max_iter
break
}
tr = crossprod(Xs, w1)
expression = max(abs(tr - total) / total)
if (any(total == 0)) expression = max(abs(tr - total))
if (expression < EPS1) break
}
if (l == max_iter) {
warning("No convergence")
g = NULL
der = g
} else {
g = w1 / d
der = g
}
}
}
set.seed(123)
n <- 10000
# Generowanie danych populacyjnych
x1 <- rlnorm(n, 0, 1)
x2 <- rexp(n, 1)
x3 <- rnorm(n, 2, 1)  # Dodatkowa zmienna, by zwiększyć wymiar Zs
y <- 1 + x1 + x2 + rnorm(n)
pr <- plogis(1 + 0.5 * x1 - 0.5 * y)
pop_data <- data.frame(x1, x2, x3, y, pr)
# Ustalanie sum kontrolnych (totals) dla Xs
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 1000  # Liczba replikacji (zmniejszona dla szybkości działania)
results <- matrix(0, n_reps, 2)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
# Xs zawiera x1 i x2 (wymiar 2)
xs <- model.matrix(~ x1 + x2, sample)
# Zs zawiera x1, x3 i y (wymiar 3)
zs <- model.matrix(~ x1 + x2 + y, sample)
d <- rep(1, NROW(sample))  # Wagi początkowe
# Skalibrowane wagi używając funkcji gencal
g_calib <- gencal(totals = totals, nonresponse = xs, calib_var = zs, target_var = y, initial_weights = d)
# Wyniki
results[r, 1] <- mean(sample$y)  # Naive
if (!is.null(g_calib)) {
results[r, 2] <- weighted.mean(sample$y, g_calib)
} else {
results[r, 2] <- NA
}
}
# Wizualizacja wyników
boxplot(results - mean(pop_data$y), names = c("Naive", "Generalized Calibration"))
abline(h = 0, col = "red")
# Obliczanie statystyk dla każdego podejścia
y_true <- pop_data$y
summary_stats <- apply(results, 2, FUN = function(x) {
bias <- mean(x, na.rm = TRUE) - mean(y_true)
sd_x <- sd(x, na.rm = TRUE)
rmse <- sqrt(bias^2 + var(x, na.rm = TRUE))
c(bias = bias, sd = sd_x, rmse = rmse)
})
print(summary_stats)
# Przykład działania z wygenerowanymi danymi
set.seed(123)
Xs <- matrix(runif(30, 1, 10), nrow = 10, ncol = 3)
Zs <- matrix(runif(30, 1, 10), nrow = 10, ncol = 3)
d <- runif(10, 1, 5)
total <- colSums(Xs) + runif(3, 0, 5)
g_weights <- gencalib(Xs = Xs, Zs = Zs, d = d, total = total, method = "raking")
print("Skalibrowane wagi:")
print(g_weights)
print("Docelowe sumy:")
print(total)
print("Sumy po kalibracji:")
print(colSums(Xs * g_weights * d))
set.seed(123)
n <- 10000
x1 <- rlnorm(n, 0, 1)
x2 <- rexp(n, 1)
x3 <-  rpois(n,2)
y <- 1 + x1 + x2 + rnorm(n)
pr <- plogis(1 + 0.5*x1 - 0.5*y)
pop_data <- data.frame(x1, x2, y, pr)
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 10000
results <- matrix(0, n_reps, 2)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
xs = model.matrix(~x1 + x2, sample)
zs = model.matrix(~x1 + y, sample)
d = rep(1, NROW(sample))
# Generalized calibration
g_generl <- mnar(totals = totals, nonresponse = xs, calib_var = zs, target_var = y, initial_weights = d, method = "gencalib")
# Naive
results[r, 1] <- mean(sample$y)
results[r, 2] <- weighted.mean(sample$y, g_generl)
}
#' @importFrom sampling gencalib
mnar <- function(totals, nonresponse, calib_var = NULL, target_var, initial_weights, method) {
if (method == "gencalib") {
weights <- gencal(totals, nonresponse, calib_var, target_var, initial_weights)
return(weights)
} else {
stop("Unknown method specified")
}
}
set.seed(123)
n <- 10000
x1 <- rlnorm(n, 0, 1)
x2 <- rexp(n, 1)
x3 <-  rpois(n,2)
y <- 1 + x1 + x2 + rnorm(n)
pr <- plogis(1 + 0.5*x1 - 0.5*y)
pop_data <- data.frame(x1, x2, y, pr)
totals <- c(N = n, colSums(pop_data[, c("x1", "x2")]))
n_reps <- 10000
results <- matrix(0, n_reps, 2)
for (r in 1:n_reps) {
flag <- rbinom(n, 1, pop_data$pr)
sample <- pop_data[flag == 1, ]
xs = model.matrix(~x1 + x2, sample)
zs = model.matrix(~x1 + y, sample)
d = rep(1, NROW(sample))
# Generalized calibration
g_generl <- mnar(totals = totals, nonresponse = xs, calib_var = zs, target_var = y, initial_weights = d, method = "gencalib")
# Naive
results[r, 1] <- mean(sample$y)
results[r, 2] <- weighted.mean(sample$y, g_generl)
}
boxplot(results - mean(pop_data$y))
abline(h = 0, col = "red")
y_true <- pop_data$y
apply(results, 2, FUN = function(x) c(bias = mean(x) - mean(y_true),
sd = sd(x),
rmse = sqrt( (mean(x) - mean(y_true))^2 + var(x))))
