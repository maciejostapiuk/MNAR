<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Calibration weighting â€¢ MNAR</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Calibration weighting">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">MNAR</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.0.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/calibration_weighting.html">Calibration weighting</a></li>
    <li><a class="dropdown-item" href="../articles/empirical_likelihood_estimation.html">Empirical Likelihood Method</a></li>
    <li><a class="dropdown-item" href="../articles/theory.html">Theory for missing not at random non-response correction</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Calibration weighting</h1>
                        <h4 data-toc-skip class="author">Maciej Ostapiuk
and Maciej BerÄ™sewicz</h4>
            
      

      <div class="d-none name"><code>calibration_weighting.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="weighting-methods">Weighting methods<a class="anchor" aria-label="anchor" href="#weighting-methods"></a>
</h2>
<p>Usually, if non-responses occur, summation in () provides
underestimated values compared to the population total from (). Thus, it
is needed to perform correction of initial weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mi>k</mi></msub><annotation encoding="application/x-tex">d_k</annotation></semantics></math>
under given sampling design - in other words, we have to perform of
described
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mi>k</mi></msub><annotation encoding="application/x-tex">d_k</annotation></semantics></math>â€™s.</p>
<p>In general we have the following settings: - <strong>Information on
the target variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
is only available for respondents.</strong></p>
<ul>
<li>
<strong>Information on auxiliary variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
is available under the following settings:</strong>
<ul>
<li>Unit-level data is available for respondents and
non-respondents.</li>
<li>Unit-level data is available only for respondents, but we have
population totals for the reference population.</li>
</ul>
</li>
</ul>
<div class="section level3">
<h3 id="case-when-dimensions-of-calibration-and-response-model-variables-coincide">Case when dimensions of calibration and response-model variables
coincide<a class="anchor" aria-label="anchor" href="#case-when-dimensions-of-calibration-and-response-model-variables-coincide"></a>
</h3>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ±</mi><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>x</mi><mi>p</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mtext mathvariant="normal">T</mtext></msup></mrow><annotation encoding="application/x-tex">\boldsymbol{x}= (x_1, x_2, ..., x_p)^{\text{T}}</annotation></semantics></math>
denote benchmark vector of chosen auxiliary variables and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ±</mi><mi>k</mi></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><msub><mn>1</mn><mi>k</mi></msub></msub><mo>,</mo><msub><mi>x</mi><msub><mn>2</mn><mi>k</mi></msub></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>x</mi><msub><mi>p</mi><mi>k</mi></msub></msub><mo stretchy="true" form="postfix">)</mo></mrow><mtext mathvariant="normal">T</mtext></msup></mrow><annotation encoding="application/x-tex">\boldsymbol{x}_{k} = (x_{1_k}, x_{2_k}, ..., x_{p_k})^{\text{T}}</annotation></semantics></math>
is the vector of auxiliary variables for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>-th
element of the sample
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>.
Settings state that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ—</mi><annotation encoding="application/x-tex">\boldsymbol{X}</annotation></semantics></math>,
which is the vector of global auxiliary variablesâ€™ values is known, i.e.
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ—</mi><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><munderover><mo>âˆ‘</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>x</mi><msub><mn>1</mn><mi>k</mi></msub></msub><mo>,</mo><munderover><mo>âˆ‘</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>x</mi><msub><mn>2</mn><mi>k</mi></msub></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><munderover><mo>âˆ‘</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>x</mi><msub><mi>p</mi><mi>k</mi></msub></msub><mo stretchy="true" form="postfix">)</mo></mrow><mtext mathvariant="normal">T</mtext></msup><mo>=</mo><munder><mo>âˆ‘</mo><mrow><mi>k</mi><mo>âˆˆ</mo><mi>U</mi></mrow></munder><msub><mi>ğ±</mi><mi>k</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq:Aux. Total}
    \boldsymbol{X}= \left(\sum_{k=1}^{N}{x_{1_k}}, \sum_{k=1}^{N}{x_{2_k}}, ..., \sum_{k=1}^{N}{x_{p_k}}\right)^{\text{T}} = \sum_{k \in U}{\boldsymbol{x}_k}. 
\end{equation}</annotation></semantics></math> If any of auxiliary
values total is not known, one might use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><msub><mi>i</mi><mi>k</mi></msub></msub><annotation encoding="application/x-tex">x_{i_{k}}</annotation></semantics></math>
instead of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>k</mi></msub><annotation encoding="application/x-tex">y_k</annotation></semantics></math>â€™s
into (),
i.e.Â <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>X</mi><mo accent="true">Ì‚</mo></mover><mtext mathvariant="normal">HT</mtext><mi>i</mi></msubsup><mo>=</mo><munderover><mo>âˆ‘</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>x</mi><msub><mi>i</mi><mi>k</mi></msub></msub><mo>,</mo><mspace width="0.278em"></mspace><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>p</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\hat{X}^{i}_{\text{HT}} = \sum_{k=1}^{N}{x_{i_k}}, \; i= 1, ..., p.</annotation></semantics></math>
However, using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\boldsymbol{x}_k</annotation></semantics></math>
instead of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>k</mi></msub><annotation encoding="application/x-tex">y_k</annotation></semantics></math>
does not always work in process of estimation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ—</mi><annotation encoding="application/x-tex">\boldsymbol{X}</annotation></semantics></math>.
One needs to perform slightly different weights than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mi>k</mi></msub><annotation encoding="application/x-tex">d_k</annotation></semantics></math>â€™s.
Those weights, denoted as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>k</mi></msub><annotation encoding="application/x-tex">w_k</annotation></semantics></math>â€™s
as solutions to optimization problem of form <span class="math display">$$\begin{equation}\label{eq: optimization w_k}
    \argmin_{w_k}{\sum_{k\in r}G_k\left(w_k,d_k\right)},
\end{equation}$$</span> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>G</mi><mi>k</mi></msub><annotation encoding="application/x-tex">G_k</annotation></semantics></math>
is a strictly convex, differentiable function, for which
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>d</mi><mi>k</mi></msub><mo>,</mo><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">G_k(d_k,d_k) = 0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>G</mi><msub><mi>â€²</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">G_k(1) = G'_k(1) = 0</annotation></semantics></math>.
Also, there exists a additional condition which has to be satisfied,
namely:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo>âˆ‘</mo><mrow><mi>k</mi><mo>âˆˆ</mo><mi>r</mi></mrow></munder><mrow><msub><mi>w</mi><mi>k</mi></msub><msub><mi>ğ±</mi><mi>k</mi></msub></mrow><mo>=</mo><munder><mo>âˆ‘</mo><mrow><mi>k</mi><mo>âˆˆ</mo><mi>U</mi></mrow></munder><msub><mi>ğ±</mi><mi>k</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq: calib eq}
    \sum_{k\in r}{w_k\boldsymbol{x}_k} = \sum_{k\in U}{\boldsymbol{x}_k}.
\end{equation}</annotation></semantics></math> Equation () is also being
called as . Using Lagrange multipliers method, it is shown in <span class="citation">Deville and SÃ¤rndal (<a href="#ref-deville1992calibration">1992</a>)</span>, that vector of
calibration weights might be written as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>k</mi></msub><mo>=</mo><msub><mi>d</mi><mi>k</mi></msub><msub><mi>F</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>ğ›Œ</mi><mtext mathvariant="normal">T</mtext></msup><msub><mi>ğ³</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq: w_k minimizers form}
    w_k = d_k F_k (\boldsymbol{\lambda}^{\text{T}}\boldsymbol{z}_k)
\end{equation}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ³</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\boldsymbol{z}_k</annotation></semantics></math>
is a vector of instrumental variables, coinciding, in sense of
dimensions with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\boldsymbol{x}_k</annotation></semantics></math>.
Later in this paper, we will consider situation where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ³</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\boldsymbol{z}_k</annotation></semantics></math>
has got higher dimension than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\boldsymbol{x}_k</annotation></semantics></math>.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>k</mi></msub><annotation encoding="application/x-tex">F_k</annotation></semantics></math>
is the inverse of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>k</mi></msub><mi>â€²</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>k</mi></msub><mo>,</mo><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">G_k'(w_k, d_k)</annotation></semantics></math>,
defined as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>k</mi></msub><mi>â€²</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>k</mi></msub><mo>,</mo><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><mi>âˆ‚</mi><mrow><msub><mi>G</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>k</mi></msub><mo>,</mo><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mrow><mrow><mi>âˆ‚</mi><msub><mi>w</mi><mi>k</mi></msub></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq: partial derivative of G_k}
    G_k'(w_k, d_k) = \frac{\partial{G_k(w_k, d_k)}}{\partial w_k}.
\end{equation}</annotation></semantics></math> There are various ideas
to choose function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>G</mi><mi>k</mi></msub><annotation encoding="application/x-tex">G_k</annotation></semantics></math>
but it is a common case to consider
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>G</mi><mi>k</mi></msub><annotation encoding="application/x-tex">G_k</annotation></semantics></math>
of form:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>k</mi></msub><mo>,</mo><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>w</mi><mi>k</mi></msub><mo>âˆ’</mo><msub><mi>d</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mrow><mn>2</mn><msub><mi>d</mi><mi>k</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq: G_k example}
    G_k(w_k,d_k) = \frac{\left(w_k - d_k\right)^2}{2d_k}
\end{equation}</annotation></semantics></math> For such choice, the
solution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>k</mi></msub><annotation encoding="application/x-tex">w_k</annotation></semantics></math>
of problem stated in () is expressed by <span class="citation">Estevao
and SÃ¤rndal (<a href="#ref-estevaofunctional2000">n.d.</a>)</span> as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>k</mi></msub><mo>=</mo><msub><mi>d</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>+</mo><msubsup><mi>ğ³</mi><mi>k</mi><mtext mathvariant="normal">T</mtext></msubsup><mi>ğ›Œ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq:G_k optimizers}
w_k = d_k(1 + \boldsymbol{z}_k^{\text{T}}\boldsymbol{\lambda}),
\end{equation}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ </mi><annotation encoding="application/x-tex">\boldsymbol{g}</annotation></semantics></math>
is defined as follows:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ </mi><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><munder><mo>âˆ‘</mo><mrow><mi>k</mi><mo>âˆˆ</mo><mi>r</mi></mrow></munder><mrow><msub><mi>d</mi><mi>k</mi></msub><msub><mi>ğ±</mi><mi>k</mi></msub><msubsup><mi>ğ³</mi><mi>k</mi><mtext mathvariant="normal">T</mtext></msubsup></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><mo>Ã—</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ—</mi><mo>âˆ’</mo><munder><mo>âˆ‘</mo><mrow><mi>k</mi><mo>âˆˆ</mo><mi>r</mi></mrow></munder><mrow><msub><mi>d</mi><mi>k</mi></msub><msub><mi>ğ±</mi><mi>k</mi></msub></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq: g vector}
    \boldsymbol{g}= \left(\sum_{k \in r}{d_k\boldsymbol{x}_k\boldsymbol{z}_k^{\text{T}}}\right)^{-1} \times \left(\boldsymbol{X}- \sum_{k\in r}{d_k \boldsymbol{x}_k}\right).
\end{equation}</annotation></semantics></math> Using obtained
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>k</mi></msub><annotation encoding="application/x-tex">w_k</annotation></semantics></math>,
known as the linear weights, a new, so called â€œcalibration-weightedâ€
estimator of target variable total from () is of the form:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>Y</mi><mo accent="true">Ì‚</mo></mover><mtext mathvariant="normal">cal</mtext></msub><mo>=</mo><munder><mo>âˆ‘</mo><mrow><mi>k</mi><mo>âˆˆ</mo><mi>r</mi></mrow></munder><mrow><msub><mi>w</mi><mi>k</mi></msub><msub><mi>y</mi><mi>k</mi></msub></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq: calibration-weighted estimator}
    \hat{Y}_{\text{cal}} = \sum_{k \in r}{w_k y_k},
\end{equation}</annotation></semantics></math> which can be rendered as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>Y</mi><mo accent="true">Ì‚</mo></mover><mtext mathvariant="normal">cal</mtext></msub><mo>=</mo><munder><mo>âˆ‘</mo><mrow><mi>k</mi><mo>âˆˆ</mo><mi>r</mi></mrow></munder><mrow><msub><mi>d</mi><mi>k</mi></msub><msub><mi>y</mi><mi>k</mi></msub></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ—</mi><mo>âˆ’</mo><munder><mo>âˆ‘</mo><mrow><mi>k</mi><mo>âˆˆ</mo><mi>r</mi></mrow></munder><mrow><msub><mi>d</mi><mi>k</mi></msub><msub><mi>ğ±</mi><mi>k</mi></msub></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>ğ›</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq: rendered calibration-weighted estimator}
    \hat{Y}_{\text{cal}} = \sum_{k \in r }{d_k y_k} + \left(\boldsymbol{X}- \sum_{k\in r}{d_k \boldsymbol{x}_k}\right)\boldsymbol{b},
\end{equation}</annotation></semantics></math> where
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ›</mi><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><munder><mo>âˆ‘</mo><mrow><mi>k</mi><mo>âˆˆ</mo><mi>r</mi></mrow></munder><mrow><msub><mi>d</mi><mi>k</mi></msub><msub><mi>ğ³</mi><mi>k</mi></msub><msubsup><mi>ğ±</mi><mi>k</mi><mtext mathvariant="normal">T</mtext></msubsup></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><mo>Ã—</mo><munder><mo>âˆ‘</mo><mrow><mi>k</mi><mo>âˆˆ</mo><mi>r</mi></mrow></munder><mrow><msub><mi>d</mi><mi>k</mi></msub><msub><mi>ğ³</mi><mi>k</mi></msub><msub><mi>y</mi><mi>k</mi></msub></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
\boldsymbol{b}= \left(\sum_{k \in r}{d_k\boldsymbol{z}_k\boldsymbol{x}_k^{\text{T}}}\right)^{-1} \times \sum_{k \in r}{d_k\boldsymbol{z}_k y_k}.
\end{equation*}</annotation></semantics></math> Notice, that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>Y</mi><mo accent="true">Ì‚</mo></mover><mrow><mi>c</mi><mi>a</mi><mi>l</mi></mrow></msub><annotation encoding="application/x-tex">\hat{Y}_{cal}</annotation></semantics></math>
is no longer unbiased by design. However it might be consistent, which
is described in <span class="citation">Isaki and Fuller (<a href="#ref-isakifuller1982">1982</a>)</span>.</p>
<p>How does one formulate the prediction model in this case? Letâ€™s
denote two indicator random variables:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>j</mi></msub><mo>=</mo><mn>1</mn><mrow><mi>j</mi><mo>âˆˆ</mo><mi>U</mi></mrow><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><msub><mi>R</mi><mi>j</mi></msub><mo>=</mo><mn>1</mn><mrow><mi>k</mi><mo>âˆˆ</mo><mi>r</mi></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
\displaystyle I_j = 1{j \in U} \;\;\; R_j = 1{k\in r}.
\end{equation*}</annotation></semantics></math><span class="citation">Kott and Chang (<a href="#ref-kottweightingnonignorable2010">2010</a>)</span> proposed the
double-protection justiï¬cation set of equations:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><msub><mi>y</mi><mi>k</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msubsup><mi>ğ±</mi><mi>k</mi><mtext mathvariant="normal">T</mtext></msubsup><msub><mi>ğ›ƒ</mi><mi>ğ±</mi></msub><mo>+</mo><msub><mi>Ïµ</mi><mi>k</mi></msub></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><msub><mi>ğ³</mi><mi>k</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msubsup><mi>ğ±</mi><mi>k</mi><mtext mathvariant="normal">T</mtext></msubsup><mi>ğšª</mi><mo>+</mo><msubsup><mi>ğ›ˆ</mi><mi>k</mi><mtext mathvariant="normal">T</mtext></msubsup><mo>,</mo></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq: double-security-pred.framework}
\left\{\begin{array}{lll} 
y_k &amp;= \boldsymbol{x}_k^{\text{T}} \boldsymbol{\beta}_{\boldsymbol{x}} + \epsilon_k\\
\boldsymbol{z}_k &amp;= \boldsymbol{x}_k^{\text{T}}\boldsymbol{\Gamma}+ \boldsymbol{\eta}_k^{\text{T}},\\
\end{array} \right.
\end{equation}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğšª</mi><annotation encoding="application/x-tex">\boldsymbol{\Gamma}</annotation></semantics></math>
is usually on full-rank (not necessarily),
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ›ƒ</mi><mi>ğ±</mi></msub><annotation encoding="application/x-tex">\boldsymbol{\beta}_{\boldsymbol{x}}</annotation></semantics></math>
is a coefficients vector and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Ïµ</mi><mi>k</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ±</mi><mi>j</mi></msub><mo>,</mo><msub><mi>I</mi><mi>j</mi></msub><mo>,</mo><msub><mi>R</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn><mo>,</mo><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ğ›ˆ</mi><mi>ğ¤</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>ğ±</mi><mi>j</mi></msub><mo>,</mo><msub><mi>I</mi><mi>j</mi></msub><mo>,</mo><msub><mi>R</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
E{\left(\epsilon_k|\boldsymbol{x}_j,I_j,R_j\right)} = 0, \;\; E{\left(\boldsymbol{\eta_k}|\boldsymbol{x}_j,I_j,R_j\right)} = 0.
\end{equation}</annotation></semantics></math> Under proposal from ()
there is a property in form of:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>k</mi></msub><mo>âˆ’</mo><msubsup><mi>ğ³</mi><mi>k</mi><mtext mathvariant="normal">T</mtext></msubsup><msub><mi>ğ›ƒ</mi><mi>ğ³</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">|</mo><msub><mi>ğ±</mi><mi>k</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>Ïµ</mi><mo>âˆ’</mo><msubsup><mi>ğ›ˆ</mi><mi>k</mi><mtext mathvariant="normal">T</mtext></msubsup><msup><mi>ğšª</mi><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><msub><mi>ğ›ƒ</mi><mi>ğ±</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">|</mo></mrow><msub><mi>ğ±</mi><mi>k</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq: property of 2-sec prediction}
\left(y_k - \boldsymbol{z}_k^{\text{T}}\boldsymbol{\beta}_{\boldsymbol{z}}\right)|\boldsymbol{x}_k = \left(\epsilon - \boldsymbol{\eta}_k^{\text{T}}\boldsymbol{\Gamma}^{-1}\boldsymbol{\beta}_{\boldsymbol{x}}\right)|\boldsymbol{x}_k,
\end{equation}</annotation></semantics></math> where
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î²</mi><mi>ğ³</mi></msub><mo>=</mo><msup><mi>Î“</mi><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><msub><mi>Î²</mi><mi>ğ±</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{equation*}
\beta_{\boldsymbol{z}} = \Gamma^{-1}\beta_{\boldsymbol{x}}.
\end{equation*}</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="when-there-are-more-calibration-than-response-model-variables">When there are more calibration than response-model variables<a class="anchor" aria-label="anchor" href="#when-there-are-more-calibration-than-response-model-variables"></a>
</h3>
<p>First, lets consider
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ğ›</mi><mi>ğ³</mi><mo>*</mo></msubsup><annotation encoding="application/x-tex">\boldsymbol{b}_{\boldsymbol{z}}^{*}</annotation></semantics></math>,
a asymptotic limit of:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ›</mi><mi>ğ³</mi></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><munder><mo>âˆ‘</mo><mrow><mi>k</mi><mo>âˆˆ</mo><mi>S</mi></mrow></munder><mrow><msub><mi>d</mi><mi>k</mi></msub><msub><mi>R</mi><mi>k</mi></msub><mi>F</mi><msub><mi>â€²</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ğ±</mi><mi>k</mi><mtext mathvariant="normal">T</mtext></msubsup><mi>ğ›Œ</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>ğ±</mi><mi>k</mi></msub></mrow><msubsup><mi>ğ³</mi><mi>k</mi><mtext mathvariant="normal">T</mtext></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><mo>Ã—</mo><munder><mo>âˆ‘</mo><mrow><mi>k</mi><mo>âˆˆ</mo><mi>S</mi></mrow></munder><mrow><msub><mi>d</mi><mi>k</mi></msub><msub><mi>R</mi><mi>k</mi></msub><mi>F</mi><msub><mi>â€²</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ğ±</mi><mi>k</mi><mtext mathvariant="normal">T</mtext></msubsup><mi>ğ›Œ</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>ğ±</mi><mi>k</mi></msub><msub><mi>y</mi><mi>k</mi></msub></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq: b_z}
    \boldsymbol{b}_{\boldsymbol{z}} =  \left(\sum_{k \in S}{d_kR_kF'_k(\boldsymbol{x}_k^{\text{T}}\boldsymbol{\lambda})\boldsymbol{x}_k}\boldsymbol{z}_k^{\text{T}}\right)^{-1} \times \sum_{k \in S}{d_kR_kF'_k(\boldsymbol{x}_k^{\text{T}}\boldsymbol{\lambda})\boldsymbol{x}_ky_k},
\end{equation}</annotation></semantics></math> which, alongside with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ›</mi><mi>ğ³</mi></msub><annotation encoding="application/x-tex">\boldsymbol{b}_{\boldsymbol{z}}</annotation></semantics></math>,
is said to exist apart from result of the prediction. When prediction
model fails, we got
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ›</mi><mi>ğ³</mi></msub><mo>âˆ’</mo><msub><mi>ğ›ƒ</mi><mi>ğ³</mi></msub></mrow><annotation encoding="application/x-tex">\boldsymbol{b}_{\boldsymbol{z}} - \boldsymbol{\beta}_{\boldsymbol{z}}</annotation></semantics></math>
as long as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ›Œ</mi><annotation encoding="application/x-tex">\boldsymbol{\lambda}</annotation></semantics></math>
converged to a finite
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ğ›Œ</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\boldsymbol{\lambda}^{*}</annotation></semantics></math>.
<span class="citation">Chang and Kott (<a href="#ref-chang_using_2008">2008</a>)</span> considered this case and
extended weighting approach by replacing the reformulated calibration
equation from ():
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ¬</mi><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><mrow><mo stretchy="true" form="prefix">[</mo><munder><mo>âˆ‘</mo><mrow><mi>k</mi><mo>âˆˆ</mo><mi>S</mi></mrow></munder><mrow><msub><mi>d</mi><mi>k</mi></msub><msub><mi>R</mi><mi>k</mi></msub><msub><mi>F</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ğ±</mi><mi>k</mi><mtext mathvariant="normal">T</mtext></msubsup><mi>ğ›Œ</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>ğ³</mi><mi>k</mi></msub></mrow><msub><mi>ğ±</mi><mi>k</mi></msub><mo>âˆ’</mo><munder><mo>âˆ‘</mo><mrow><mi>k</mi><mo>âˆˆ</mo><mi>S</mi></mrow></munder><mrow><msub><mi>d</mi><mi>k</mi></msub><msub><mi>ğ±</mi><mi>k</mi></msub></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mn>ğŸ</mn></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq: reformulated calib. eq.}
\boldsymbol{s} = \frac{1}{N} \left[\sum_{k \in S}{d_kR_kF_k(\boldsymbol{x}_k^{\text{T}}\boldsymbol{\lambda})\boldsymbol{z}_k}\boldsymbol{x}_k- \sum_{k \in S}{d_k\boldsymbol{x}_k}\right] = \boldsymbol{0}
\end{equation}</annotation></semantics></math> by finding
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ›Œ</mi><annotation encoding="application/x-tex">\boldsymbol{\lambda}</annotation></semantics></math>
that minimizes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ğ¬</mi><mtext mathvariant="normal">T</mtext></msup><mi>ğ</mi><mi>ğ¬</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{s}^{\text{T}}\boldsymbol{Q}\boldsymbol{s}</annotation></semantics></math>
for some symmetric and positive
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ</mi><annotation encoding="application/x-tex">\boldsymbol{Q}</annotation></semantics></math>.
There are various ways to pick
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ</mi><annotation encoding="application/x-tex">\boldsymbol{Q}</annotation></semantics></math>
as well as dealing with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğšª</mi><annotation encoding="application/x-tex">\boldsymbol{\Gamma}</annotation></semantics></math>
not being on full rank. Couple of examples might be found in <span class="citation">Kott and Liao (<a href="#ref-kottliaoalowingmorecalib2017">2017</a>)</span>. For example,
one of the options is to use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ğ</mi><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><mo>=</mo><mtext mathvariant="normal">DIAG</mtext><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>N</mi><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><msub><mo>âˆ‘</mo><mi>S</mi></msub><msub><mi>d</mi><mi>k</mi></msub><msub><mi>ğ±</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>N</mi><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><msub><mo>âˆ‘</mo><mi>S</mi></msub><msub><mi>d</mi><mi>k</mi></msub><msubsup><mi>ğ±</mi><mi>k</mi><mi>âŠ¤</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\displaystyle \mathbf{\boldsymbol{Q}}^{-1} = \text{DIAG}\left[\left({N}^{-1} \sum_{S} d_k \mathbf{\boldsymbol{x}}_k\right) \left({N}^{-1}\sum_{S} d_k \mathbf{\boldsymbol{x}}_k^\top \right)\right]</annotation></semantics></math>.
After finding
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ›Œ</mi><annotation encoding="application/x-tex">\boldsymbol{\lambda}</annotation></semantics></math>,
dimension of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>ğ±</mi><mi>k</mi><mtext mathvariant="normal">T</mtext></msubsup><annotation encoding="application/x-tex">\boldsymbol{x}_k^{\text{T}}</annotation></semantics></math>
is reduced in such way:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mover><mi>ğ±</mi><mo accent="true">Ìƒ</mo></mover><mi>k</mi><mi>T</mi></msubsup></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msup><mi>N</mi><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><mi>ğ</mi><munder><mo>âˆ‘</mo><mrow><mi>j</mi><mo>âˆˆ</mo><mi>S</mi></mrow></munder><msub><mi>d</mi><mi>j</mi></msub><msub><mi>R</mi><mi>j</mi></msub><msub><mi>F</mi><mi>k</mi></msub><mi>â€²</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ğ³</mi><mi>j</mi><mi>T</mi></msubsup><mi>ğ›Œ</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>ğ±</mi><mi>j</mi></msub><msubsup><mi>ğ³</mi><mi>j</mi><mi>T</mi></msubsup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msubsup><mi>ğ±</mi><mi>k</mi><mi>T</mi></msubsup><msup><mrow><mo stretchy="true" form="prefix">(</mo><munder><mo>âˆ‘</mo><mrow><mi>j</mi><mo>âˆˆ</mo><mi>S</mi></mrow></munder><msub><mi>d</mi><mi>j</mi></msub><msub><mi>R</mi><mi>j</mi></msub><msub><mi>F</mi><mi>k</mi></msub><mi>â€²</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ğ³</mi><mi>j</mi><mi>T</mi></msubsup><mi>ğ›Œ</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>ğ±</mi><mi>j</mi></msub><msubsup><mi>ğ±</mi><mi>j</mi><mi>T</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><munder><mo>âˆ‘</mo><mrow><mi>j</mi><mo>âˆˆ</mo><mi>S</mi></mrow></munder><msub><mi>d</mi><mi>j</mi></msub><msub><mi>R</mi><mi>j</mi></msub><msub><mi>F</mi><mi>k</mi></msub><mi>â€²</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>ğ³</mi><mi>j</mi><mi>T</mi></msubsup><mi>ğ </mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>ğ±</mi><mi>j</mi></msub><msubsup><mi>ğ³</mi><mi>j</mi><mi>T</mi></msubsup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msubsup><mi>ğ±</mi><mi>k</mi><mi>T</mi></msubsup><msub><mi>ğ</mi><mi>ğ³</mi></msub><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
\tilde{\boldsymbol{x}}_k^T &amp;= N^{-1} \boldsymbol{Q}\sum_{j \in S} d_j R_j F_k' \left( \boldsymbol{z}_j^T \boldsymbol{\lambda}\right) \boldsymbol{x}_j \boldsymbol{z}_j^T\\
&amp;= \boldsymbol{x}_k^T \left( \sum_{j \in S} d_j R_j F_k' \left( \boldsymbol{z}_j^T \boldsymbol{\lambda}\right) \boldsymbol{x}_j \boldsymbol{x}_j^T \right)^{-1} \sum_{j \in S} d_j R_j F_k' \left( \boldsymbol{z}_j^T \mathbf{g} \right) \boldsymbol{x}_j \boldsymbol{z}_j^T\\
&amp;= \boldsymbol{x}_k^T \mathbf{B}_{\boldsymbol{z}}.
\end{align*}</annotation></semantics></math> Another approach to
component reduction, proposed by <span class="citation">Andridge and
Little (<a href="#ref-andridge2011proxy">2011</a>)</span>, works without
searching
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ›Œ</mi><annotation encoding="application/x-tex">\boldsymbol{\lambda}</annotation></semantics></math>
or does not even rely on picking
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ</mi><annotation encoding="application/x-tex">\boldsymbol{Q}</annotation></semantics></math>
matrix- idea relies on satisfying
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo>âˆ‘</mo><mrow><mi>k</mi><mo>âˆˆ</mo><mi>S</mi></mrow></munder><msub><mi>w</mi><mi>k</mi></msub><msub><mover><mi>ğ±</mi><mo accent="true">Ìƒ</mo></mover><mi>k</mi></msub><mo>=</mo><munder><mo>âˆ‘</mo><mrow><mi>k</mi><mo>âˆˆ</mo><mi>S</mi></mrow></munder><msub><mi>d</mi><mi>k</mi></msub><msub><mi>R</mi><mi>k</mi></msub><msub><mi>F</mi><mi>k</mi></msub><msub><mover><mi>ğ±</mi><mo accent="true">Ìƒ</mo></mover><mi>k</mi></msub><mo>=</mo><munder><mo>âˆ‘</mo><mrow><mi>k</mi><mo>âˆˆ</mo><mi>S</mi></mrow></munder><msub><mi>d</mi><mi>k</mi></msub><msub><mover><mi>ğ±</mi><mo accent="true">Ìƒ</mo></mover><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq: reformulated calib.eq}
\sum_{k \in S} w_k \tilde{\boldsymbol{x}}_k = \sum_{k \in S} d_k R_k F_k \tilde{\boldsymbol{x}}_k = \sum_{k \in S} d_k \tilde{\boldsymbol{x}}_k
\end{equation}</annotation></semantics></math> and setting
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>ğ±</mi><mo accent="true">Ìƒ</mo></mover><mi>k</mi><mtext mathvariant="normal">T</mtext></msubsup><mo>=</mo><msubsup><mi>ğ±</mi><mi>k</mi><mtext mathvariant="normal">T</mtext></msubsup><msup><mi>ğ€</mi><mtext mathvariant="normal">T</mtext></msup><mo>,</mo></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq: setting A&amp;L}
\tilde{\boldsymbol{x}}_k^{\text{T}} = \boldsymbol{x}_k^{\text{T}}\boldsymbol{A}^{\text{T}},
\end{equation}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ğ€</mi><mtext mathvariant="normal">T</mtext></msup><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>âˆ‘</mo><mi>S</mi></msub><mrow><msub><mi>R</mi><mi>j</mi></msub><msub><mi>ğ±</mi><mi>j</mi></msub><msubsup><mi>ğ±</mi><mi>j</mi><mtext mathvariant="normal">T</mtext></msubsup></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msup><msub><mo>âˆ‘</mo><mi>S</mi></msub><mrow><msub><mi>R</mi><mi>j</mi></msub><msub><mi>ğ±</mi><mi>j</mi></msub><msubsup><mi>ğ³</mi><mi>j</mi><mtext mathvariant="normal">T</mtext></msubsup></mrow></mrow><annotation encoding="application/x-tex">\boldsymbol{A}^{\text{T}} =\left(\sum_{S}{R_j\boldsymbol{x}_j\boldsymbol{x}_j^{\text{T}}}\right)^{-1} \sum_{S}{R_j\boldsymbol{x}_j\boldsymbol{z}_j^{\text{T}}}</annotation></semantics></math>.
Again, the reduction of dimensions is needed and with such obtained
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>ğ±</mi><mo accent="true">Ìƒ</mo></mover><mi>k</mi></msub><annotation encoding="application/x-tex">\tilde{\boldsymbol{x}}_k</annotation></semantics></math>
one is able to perform generalized calibration weighting technique. By
far, this method is implemented as a part of <code>MNAR:gencal()</code>
function.</p>
</div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-andridge2011proxy" class="csl-entry">
Andridge, Rebecca R, and Roderick JA Little. 2011. <span>â€œProxy
Pattern-Mixture Analysis for Survey Nonresponse.â€</span> <em>Journal of
Official Statistics</em> 27 (2): 153.
</div>
<div id="ref-chang_using_2008" class="csl-entry">
Chang, T., and P. S. Kott. 2008. <span>â€œUsing Calibration Weighting to
Adjust for Nonresponse Under a Plausible Model.â€</span>
<em>Biometrika</em> 95 (3): 555â€“71. <a href="https://doi.org/10.1093/biomet/asn022" class="external-link">https://doi.org/10.1093/biomet/asn022</a>.
</div>
<div id="ref-deville1992calibration" class="csl-entry">
Deville, Jean-Claude, and Carl-Erik SÃ¤rndal. 1992. <span>â€œCalibration
Estimators in Survey Sampling.â€</span> <em>Journal of the American
Statistical Association</em> 87 (418): 376â€“82.
</div>
<div id="ref-estevaofunctional2000" class="csl-entry">
Estevao, Victor, and Carl SÃ¤rndal. n.d. <span>â€œA <span>Functional</span>
<span>Form</span> <span>Approach</span> to
<span>Calibration</span>.â€</span> <em>Journal of OfÂ®cial Statistics</em>
16 (4): 379Â±399. <a href="https://www.proquest.com/scholarly-journals/functional-form-approach-calibration/docview/1266846662/se-2" class="external-link">https://www.proquest.com/scholarly-journals/functional-form-approach-calibration/docview/1266846662/se-2</a>.
</div>
<div id="ref-isakifuller1982" class="csl-entry">
Isaki, C. T., and W. A. Fuller. 1982. <span>â€œSurvey Design Under the
Regression Super-Population Model.â€</span> <em>Journal of the American
Statistical Association</em> 77 (377): 89â€“96.
</div>
<div id="ref-kottweightingnonignorable2010" class="csl-entry">
Kott, Phillip S., and Ted Chang. 2010. <span>â€œUsing
<span>Calibration</span> <span>Weighting</span> to <span>Adjust</span>
for <span>Nonignorable</span> <span>Unit</span>
<span>Nonresponse</span>.â€</span> <em>Journal of the American
Statistical Association</em> 105 (491): 1265â€“75. <a href="https://doi.org/10.1198/jasa.2010.tm09016" class="external-link">https://doi.org/10.1198/jasa.2010.tm09016</a>.
</div>
<div id="ref-kottliaoalowingmorecalib2017" class="csl-entry">
Kott, Phillip S., and Dan Liao. 2017. <span>â€œCalibration
<span>Weighting</span> for <span>Nonresponse</span> That Is
<span>Not</span> <span>Missing</span> at <span>Random</span>:
<span>Allowing</span> <span>More</span> <span>Calibration</span> Than
<span>Response</span>-<span>Model</span> <span>Variables</span>.â€</span>
<em>Journal of Survey Statistics and Methodology</em> 5 (2): 159â€“74. <a href="https://doi.org/10.1093/jssam/smx003" class="external-link">https://doi.org/10.1093/jssam/smx003</a>.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Maciej Ostapiuk, Maciej BerÄ™sewicz.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
