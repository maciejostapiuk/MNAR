[{"path":"https://maciejostapiuk.github.io/MNAR/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 MNAR authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://maciejostapiuk.github.io/MNAR/articles/theory.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Theory for missing not at random non-response correction","text":"document reveals theory needed understand methodology behind correction missing random type non-responses survey samples. covers methods : Generalized calibration Generalized calibration variables calibration response model Generalized method moments (also known GMM) Empirical likelihood estimation Non-parametric methods Exponential tilting Latent approach Knowledge included particular paper allows one understand correction techniques treated one supplementary resource R programming language package called MNAR.","code":""},{"path":"https://maciejostapiuk.github.io/MNAR/articles/theory.html","id":"interpretation-of-missing-not-at-random","dir":"Articles","previous_headings":"","what":"Interpretation of Missing Not at Random","title":"Theory for missing not at random non-response correction","text":"statistical surveys, missing data plays important role family non-random errors. presence affects process estimating unknown global values population biasing given estimators reducing precision. reason behavior lies characteristics differences respondents—participants answered every question—participants manage provide answers every question (item non-response) answer (unit non-response), called non-respondents. happens bunch methods deal non-responses. However, main idea behind construction allows us categorize —split weighting methods imputation methods. cases, one able determine groups methods shall used. imputation methods used dealing item non-response—questions lack answers corrected , e.g., replenishing missing data. weighting methods shall used dealing unit non-responses order correct, using set auxiliary variables, weights respondents non-respondents sample known population totals reproduced. choice mentioned auxiliary variables matters strictly tied estimation process, thus arises biggest problem category methods. One might use combination kinds methods eliminate negative impact non-responses. Investigation described methodology starts explanation assumptions, settings, notation behind sampling, responding, estimation. Starting basic notation, let UU denote population size NN probability sample ss length nn, s⊆Us \\subseteq U, n≤Nn \\leq N. According sampling design, let πk\\pi_k denote first-order inclusion probability kk-th element population UU sample ss. Thus, given sampling design, dk=1πkd_k = \\frac{1}{\\pi_k} denotes initial weight kk-th element. main goal, dealing survey data, estimate total population UU, written Y=∑k=1Nyk,\\begin{equation}\\label{eq:Pop. total} Y = \\sum_{k=1}^{N}{y_k}, \\end{equation} yky_k value target variable YY kk-th element, k=1,...,Nk = 1,...,N. Natural usual choice consider Horvitz-Thompson estimator form: ŶHT=∑k∈sdkyk.\\begin{equation}\\label{eq:HT estimator} \\hat{Y}_{\\text{HT}} = \\sum_{k \\s}{d_k y_k}. \\end{equation} design, ŶHT\\hat{Y}_{\\text{HT}} unbiased estimator. happens non-respondents sample, summation done subset rr respondents, r⊆sr \\subseteq s.","code":""},{"path":"https://maciejostapiuk.github.io/MNAR/articles/theory.html","id":"weighting-methods","dir":"Articles","previous_headings":"","what":"Weighting methods","title":"Theory for missing not at random non-response correction","text":"Usually, non-responses occur, summation () provides underestimated values compared population total (). Thus, needed perform correction initial weights dkd_k given sampling design - words, perform described dkd_k’s. general following settings: - Information target variable YY available respondents. Unit-level data available respondents non-respondents. Unit-level data available respondents, population totals reference population.","code":""},{"path":"https://maciejostapiuk.github.io/MNAR/articles/theory.html","id":"case-when-dimensions-of-calibration-and-response-model-variables-coincide","dir":"Articles","previous_headings":"Weighting methods","what":"Case when dimensions of calibration and response-model variables coincide","title":"Theory for missing not at random non-response correction","text":"Let 𝐱=(x1,x2,...,xp)T\\boldsymbol{x}= (x_1, x_2, ..., x_p)^{\\text{T}} denote benchmark vector chosen auxiliary variables 𝐱k=(x1k,x2k,...,xpk)T\\boldsymbol{x}_{k} = (x_{1_k}, x_{2_k}, ..., x_{p_k})^{\\text{T}} vector auxiliary variables kk-th element sample ss. Settings state 𝐗\\boldsymbol{X}, vector global auxiliary variables’ values known, .e. 𝐗=(∑k=1Nx1k,∑k=1Nx2k,...,∑k=1Nxpk)T=∑k∈U𝐱k.\\begin{equation}\\label{eq:Aux. Total}     \\boldsymbol{X}= \\left(\\sum_{k=1}^{N}{x_{1_k}}, \\sum_{k=1}^{N}{x_{2_k}}, ..., \\sum_{k=1}^{N}{x_{p_k}}\\right)^{\\text{T}} = \\sum_{k \\U}{\\boldsymbol{x}_k}.  \\end{equation} auxiliary values total known, one might use xikx_{i_{k}} instead yky_k’s (), .e. X̂HTi=∑k=1Nxik,=1,...,p.\\hat{X}^{}_{\\text{HT}} = \\sum_{k=1}^{N}{x_{i_k}}, \\; = 1, ..., p. However, using 𝐱k\\boldsymbol{x}_k instead yky_k always work process estimation 𝐗\\boldsymbol{X}. One needs perform slightly different weights dkd_k’s. weights, denoted wkw_k’s solutions optimization problem form argminwk∑k∈rGk(wk,dk),\\begin{equation}\\label{eq: optimization w_k}     \\operatorname{argmin}_{w_k}{\\sum_{k\\r}G_k\\left(w_k,d_k\\right)}, \\end{equation} GkG_k strictly convex, differentiable function, Gk(dk,dk)=0G_k(d_k,d_k) = 0 Gk(1)=G′k(1)=0G_k(1) = G'_k(1) = 0. Also, exists additional condition satisfied, namely: ∑k∈rwk𝐱k=∑k∈U𝐱k.\\begin{equation}\\label{eq: calib eq}     \\sum_{k\\r}{w_k\\boldsymbol{x}_k} = \\sum_{k\\U}{\\boldsymbol{x}_k}. \\end{equation} Equation () also called . Using Lagrange multipliers method, shown Deville Särndal (1992), vector calibration weights might written : wk=dkFk(𝛌T𝐳k)\\begin{equation}\\label{eq: w_k minimizers form}     w_k = d_k F_k (\\boldsymbol{\\lambda}^{\\text{T}}\\boldsymbol{z}_k) \\end{equation} 𝐳k\\boldsymbol{z}_k vector instrumental variables, coinciding, sense dimensions 𝐱k\\boldsymbol{x}_k. Later paper, consider situation 𝐳k\\boldsymbol{z}_k got higher dimension 𝐱k\\boldsymbol{x}_k. FkF_k inverse Gk′(wk,dk)G_k'(w_k, d_k), defined : Gk′(wk,dk)=∂Gk(wk,dk)∂wk.\\begin{equation}\\label{eq: partial derivative G_k}     G_k'(w_k, d_k) = \\frac{\\partial{G_k(w_k, d_k)}}{\\partial w_k}. \\end{equation} various ideas choose function GkG_k common case consider GkG_k form: Gk(wk,dk)=(wk−dk)22dk\\begin{equation}\\label{eq: G_k example}     G_k(w_k,d_k) = \\frac{\\left(w_k - d_k\\right)^2}{2d_k} \\end{equation} choice, solution wkw_k problem stated () expressed Estevao Särndal (n.d.) : wk=dk(1+𝐳kT𝛌),\\begin{equation}\\label{eq:G_k optimizers} w_k = d_k(1 + \\boldsymbol{z}_k^{\\text{T}}\\boldsymbol{\\lambda}), \\end{equation} 𝐠\\boldsymbol{g} defined follows: 𝐠=(∑k∈rdk𝐱k𝐳kT)−1×(𝐗−∑k∈rdk𝐱k).\\begin{equation}\\label{eq: g vector}     \\boldsymbol{g}= \\left(\\sum_{k \\r}{d_k\\boldsymbol{x}_k\\boldsymbol{z}_k^{\\text{T}}}\\right)^{-1} \\times \\left(\\boldsymbol{X}- \\sum_{k\\r}{d_k \\boldsymbol{x}_k}\\right). \\end{equation} Using obtained wkw_k, known linear weights, new, called “calibration-weighted” estimator target variable total () form: Ŷcal=∑k∈rwkyk,\\begin{equation}\\label{eq: calibration-weighted estimator}     \\hat{Y}_{\\text{cal}} = \\sum_{k \\r}{w_k y_k}, \\end{equation} can rendered : Ŷcal=∑k∈rdkyk+(𝐗−∑k∈rdk𝐱k)𝐛,\\begin{equation}\\label{eq: rendered calibration-weighted estimator}     \\hat{Y}_{\\text{cal}} = \\sum_{k \\r }{d_k y_k} + \\left(\\boldsymbol{X}- \\sum_{k\\r}{d_k \\boldsymbol{x}_k}\\right)\\boldsymbol{b}, \\end{equation} 𝐛=(∑k∈rdk𝐳k𝐱kT)−1×∑k∈rdk𝐳kyk.\\begin{equation*} \\boldsymbol{b}= \\left(\\sum_{k \\r}{d_k\\boldsymbol{z}_k\\boldsymbol{x}_k^{\\text{T}}}\\right)^{-1} \\times \\sum_{k \\r}{d_k\\boldsymbol{z}_k y_k}. \\end{equation*} Notice, Ŷcal\\hat{Y}_{cal} longer unbiased design. However might consistent, described Isaki Fuller (1982). one formulate prediction model case? Let’s denote two indicator random variables: Ij=1j∈URj=1k∈r.\\begin{equation*} \\displaystyle I_j = 1{j \\U} \\;\\;\\; R_j = 1{k\\r}. \\end{equation*}Kott Chang (2010) proposed double-protection justiﬁcation set equations: {yk=𝐱kT𝛃𝐱+ϵk𝐳k=𝐱kT𝚪+𝛈kT,\\begin{equation}\\label{eq: double-security-pred.framework} \\left\\{\\begin{array}{lll}  y_k &= \\boldsymbol{x}_k^{\\text{T}} \\boldsymbol{\\beta}_{\\boldsymbol{x}} + \\epsilon_k\\\\ \\boldsymbol{z}_k &= \\boldsymbol{x}_k^{\\text{T}}\\boldsymbol{\\Gamma}+ \\boldsymbol{\\eta}_k^{\\text{T}},\\\\ \\end{array} \\right. \\end{equation} 𝚪\\boldsymbol{\\Gamma} usually full-rank (necessarily), 𝛃𝐱\\boldsymbol{\\beta}_{\\boldsymbol{x}} coefficients vector E(ϵk|𝐱j,Ij,Rj)=0,E(𝛈𝐤|𝐱j,Ij,Rj)=0.\\begin{equation} E{\\left(\\epsilon_k|\\boldsymbol{x}_j,I_j,R_j\\right)} = 0, \\;\\; E{\\left(\\boldsymbol{\\eta_k}|\\boldsymbol{x}_j,I_j,R_j\\right)} = 0. \\end{equation} proposal () property form : (yk−𝐳kT𝛃𝐳)|𝐱k=(ϵ−𝛈kT𝚪−1𝛃𝐱)|𝐱k,\\begin{equation}\\label{eq: property 2-sec prediction} \\left(y_k - \\boldsymbol{z}_k^{\\text{T}}\\boldsymbol{\\beta}_{\\boldsymbol{z}}\\right)|\\boldsymbol{x}_k = \\left(\\epsilon - \\boldsymbol{\\eta}_k^{\\text{T}}\\boldsymbol{\\Gamma}^{-1}\\boldsymbol{\\beta}_{\\boldsymbol{x}}\\right)|\\boldsymbol{x}_k, \\end{equation} β𝐳=Γ−1β𝐱.\\begin{equation*} \\beta_{\\boldsymbol{z}} = \\Gamma^{-1}\\beta_{\\boldsymbol{x}}. \\end{equation*}","code":""},{"path":"https://maciejostapiuk.github.io/MNAR/articles/theory.html","id":"when-there-are-more-calibration-than-response-model-variables","dir":"Articles","previous_headings":"Weighting methods","what":"When there are more calibration than response-model variables","title":"Theory for missing not at random non-response correction","text":"First, lets consider 𝐛𝐳*\\boldsymbol{b}_{\\boldsymbol{z}}^{*}, asymptotic limit : 𝐛𝐳=(∑k∈SdkRkF′k(𝐱kT𝛌)𝐱k𝐳kT)−1×∑k∈SdkRkF′k(𝐱kT𝛌)𝐱kyk,\\begin{equation}\\label{eq: b_z}     \\boldsymbol{b}_{\\boldsymbol{z}} =  \\left(\\sum_{k \\S}{d_kR_kF'_k(\\boldsymbol{x}_k^{\\text{T}}\\boldsymbol{\\lambda})\\boldsymbol{x}_k}\\boldsymbol{z}_k^{\\text{T}}\\right)^{-1} \\times \\sum_{k \\S}{d_kR_kF'_k(\\boldsymbol{x}_k^{\\text{T}}\\boldsymbol{\\lambda})\\boldsymbol{x}_ky_k}, \\end{equation} , alongside 𝐛𝐳\\boldsymbol{b}_{\\boldsymbol{z}}, said exist apart result prediction. prediction model fails, got 𝐛𝐳−𝛃𝐳\\boldsymbol{b}_{\\boldsymbol{z}} - \\boldsymbol{\\beta}_{\\boldsymbol{z}} long 𝛌\\boldsymbol{\\lambda} converged finite 𝛌*\\boldsymbol{\\lambda}^{*}. Chang Kott (2008) considered case extended weighting approach replacing reformulated calibration equation (): 𝐬=1N[∑k∈SdkRkFk(𝐱kT𝛌)𝐳k𝐱k−∑k∈Sdk𝐱k]=𝟎\\begin{equation}\\label{eq: reformulated calib. eq.} \\boldsymbol{s} = \\frac{1}{N} \\left[\\sum_{k \\S}{d_kR_kF_k(\\boldsymbol{x}_k^{\\text{T}}\\boldsymbol{\\lambda})\\boldsymbol{z}_k}\\boldsymbol{x}_k- \\sum_{k \\S}{d_k\\boldsymbol{x}_k}\\right] = \\boldsymbol{0} \\end{equation} finding 𝛌\\boldsymbol{\\lambda} minimizes 𝐬T𝐐𝐬\\boldsymbol{s}^{\\text{T}}\\boldsymbol{Q}\\boldsymbol{s} symmetric positive 𝐐\\boldsymbol{Q}. various ways pick 𝐐\\boldsymbol{Q} well dealing 𝚪\\boldsymbol{\\Gamma} full rank. Couple examples might found Kott Liao (2017). example, one options use 𝐐−1=DIAG[(N−1∑Sdk𝐱k)(N−1∑Sdk𝐱k⊤)]\\displaystyle \\mathbf{\\boldsymbol{Q}}^{-1} = \\text{DIAG}\\left[\\left({N}^{-1} \\sum_{S} d_k \\mathbf{\\boldsymbol{x}}_k\\right) \\left({N}^{-1}\\sum_{S} d_k \\mathbf{\\boldsymbol{x}}_k^\\top \\right)\\right]. finding 𝛌\\boldsymbol{\\lambda}, dimension 𝐱kT\\boldsymbol{x}_k^{\\text{T}} reduced way: 𝐱̃kT=N−1𝐐∑j∈SdjRjFk′(𝐳jT𝛌)𝐱j𝐳jT=𝐱kT(∑j∈SdjRjFk′(𝐳jT𝛌)𝐱j𝐱jT)−1∑j∈SdjRjFk′(𝐳jT𝐠)𝐱j𝐳jT=𝐱kT𝐁𝐳.\\begin{align*} \\tilde{\\boldsymbol{x}}_k^T &= N^{-1} \\boldsymbol{Q}\\sum_{j \\S} d_j R_j F_k' \\left( \\boldsymbol{z}_j^T \\boldsymbol{\\lambda}\\right) \\boldsymbol{x}_j \\boldsymbol{z}_j^T\\\\ &= \\boldsymbol{x}_k^T \\left( \\sum_{j \\S} d_j R_j F_k' \\left( \\boldsymbol{z}_j^T \\boldsymbol{\\lambda}\\right) \\boldsymbol{x}_j \\boldsymbol{x}_j^T \\right)^{-1} \\sum_{j \\S} d_j R_j F_k' \\left( \\boldsymbol{z}_j^T \\mathbf{g} \\right) \\boldsymbol{x}_j \\boldsymbol{z}_j^T\\\\ &= \\boldsymbol{x}_k^T \\mathbf{B}_{\\boldsymbol{z}}. \\end{align*} Another approach component reduction, proposed Andridge Little (2011), works without searching 𝛌\\boldsymbol{\\lambda} even rely picking 𝐐\\boldsymbol{Q} matrix- idea relies satisfying ∑k∈Swk𝐱̃k=∑k∈SdkRkFk𝐱̃k=∑k∈Sdk𝐱̃k\\begin{equation}\\label{eq: reformulated calib.eq} \\sum_{k \\S} w_k \\tilde{\\boldsymbol{x}}_k = \\sum_{k \\S} d_k R_k F_k \\tilde{\\boldsymbol{x}}_k = \\sum_{k \\S} d_k \\tilde{\\boldsymbol{x}}_k \\end{equation} setting 𝐱̃kT=𝐱kT𝐀T,\\begin{equation}\\label{eq: setting &L} \\tilde{\\boldsymbol{x}}_k^{\\text{T}} = \\boldsymbol{x}_k^{\\text{T}}\\boldsymbol{}^{\\text{T}}, \\end{equation} 𝐀T=(∑SRj𝐱j𝐱jT)−1∑SRj𝐱j𝐳jT\\boldsymbol{}^{\\text{T}} =\\left(\\sum_{S}{R_j\\boldsymbol{x}_j\\boldsymbol{x}_j^{\\text{T}}}\\right)^{-1} \\sum_{S}{R_j\\boldsymbol{x}_j\\boldsymbol{z}_j^{\\text{T}}}. , reduction dimensions needed obtained 𝐱̃k\\tilde{\\boldsymbol{x}}_k one able perform generalized calibration weighting technique. far, method implemented part MNAR:gencal() function.","code":""},{"path":[]},{"path":"https://maciejostapiuk.github.io/MNAR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Maciej Ostapiuk. Author, maintainer. Maciej Beręsewicz. Author, contributor.","code":""},{"path":"https://maciejostapiuk.github.io/MNAR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ostapiuk M, Beręsewicz M (2024). MNAR: package deal Missing Random non-response. R package version 0.0.0.9000, https://maciejostapiuk.github.io/MNAR/.","code":"@Manual{,   title = {MNAR: A package to deal with Not Missing at Random non-response},   author = {Maciej Ostapiuk and Maciej Beręsewicz},   year = {2024},   note = {R package version 0.0.0.9000},   url = {https://maciejostapiuk.github.io/MNAR/}, }"},{"path":[]},{"path":"https://maciejostapiuk.github.io/MNAR/index.html","id":"details","dir":"","previous_headings":"","what":"Details","title":"A package to deal with Not Missing at Random non-response","text":"R package Missing Random","code":""},{"path":"https://maciejostapiuk.github.io/MNAR/index.html","id":"funding","dir":"","previous_headings":"","what":"Funding","title":"A package to deal with Not Missing at Random non-response","text":"Work package supported National Science Centre, OPUS 20 grant . 2020/39/B/HS4/00941.","code":""},{"path":"https://maciejostapiuk.github.io/MNAR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A package to deal with Not Missing at Random non-response","text":"can install development version MNAR GitHub :","code":"# install.packages(\"remotes\") remotes::install_github(\"maciejostapiuk/MNAR\")"},{"path":"https://maciejostapiuk.github.io/MNAR/reference/gencal.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized calibration function based on sampling::gencalib — gencal","title":"Generalized calibration function based on sampling::gencalib — gencal","text":"Importing","code":""},{"path":"https://maciejostapiuk.github.io/MNAR/reference/gencal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized calibration function based on sampling::gencalib — gencal","text":"","code":"gencal(Xs, Zs, d, pop_totals, method = \"raking\", eps, maxit, tol)"},{"path":"https://maciejostapiuk.github.io/MNAR/reference/gencal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized calibration function based on sampling::gencalib — gencal","text":"Xs matrix calibration variables Zs matrix instrumental variables d vector initial weights, derived sampling design method method upon sampling::gencalib() function called eps describes desired accuracy level convergence-related maxit maximum number iterations sampling::gencalib() since works iteratively tol desired tolerance totals vector population totals (including totals Xs Zs)","code":""},{"path":"https://maciejostapiuk.github.io/MNAR/reference/gencal.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generalized calibration function based on sampling::gencalib — gencal","text":"Andridge, Rebecca R, Roderick JA Little. 2011. “Proxy Pattern-Mixture Analysis Survey Nonresponse.” Journal Official Statistics 27 (2): 153. Chang, T., P. S. Kott. 2008. “Using Calibration Weighting Adjust Nonresponse Plausible Model.” Biometrika 95 (3): 555–71. https://doi.org/10.1093/biomet/asn022. Deville, Jean-Claude, Carl-Erik Särndal. 1992. “Calibration Estimators Survey Sampling.” Journal American Statistical Association 87 (418): 376–82. Estevao, Victor, Carl Särndal. n.d. “Functional Form Approach Calibration.” Journal ®cial Statistics 16 (4): 379±399. https://www.proquest.com/scholarly-journals/functional-form-approach-calibration/docview/1266846662/se-2. Isaki, C. T., W. . Fuller. 1982. “Survey Design Regression Super-Population Model.” Journal American Statistical Association 77 (377): 89–96. Kott, Phillip S., Ted Chang. 2010. “Using Calibration Weighting Adjust Nonignorable Unit Nonresponse.” Journal American Statistical Association 105 (491): 1265–75. https://doi.org/10.1198/jasa.2010.tm09016. Kott, Phillip S., Dan Liao. 2017. “Calibration Weighting Nonresponse Missing Random: Allowing Calibration Response-Model Variables.” Journal Survey Statistics Methodology 5 (2): 159–74. https://doi.org/10.1093/jssam/smx003.","code":""},{"path":"https://maciejostapiuk.github.io/MNAR/reference/gencal.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generalized calibration function based on sampling::gencalib — gencal","text":"Maciej Ostapiuk Maciej Beręsewicz based Kott Chang (2010) Kott Liao (2017)","code":""},{"path":"https://maciejostapiuk.github.io/MNAR/reference/gencal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized calibration function based on sampling::gencalib — gencal","text":"","code":"## Generate the data to formulate response model, calibration variables and target variable  set.seed(123) n <- 10000 x1 <- rlnorm(n, 0, 1) x2 <- rexp(n, 1) x3 <-  rpois(n,2) y <- 1 + x1 + x2 + rnorm(n) pr <- plogis(1 + 0.5*x1 - 0.5*y) pop_data <- data.frame(x1, x2, y, pr) totals <- c(N = n, colSums(pop_data[, c(\"x1\", \"x2\", \"y\")])) flag <- rbinom(n, 1, pop_data$pr) sample <- pop_data[flag == 1, ] sample$d <- n/nrow(sample)  ## case when dim(Xs) == dim(Zs) g <- gencal(Xs = stats::model.matrix(~ x1 + x2, data = sample),             Zs = stats::model.matrix(~ x1 + y, data = sample),             d = sample$d,             pop_totals = totals,             method = \"raking\",             eps = .Machine$double.eps,             maxit = 100,             tol = 1e-8)  head(g) #display only couple of first output values #> [1] 1.1800080 2.6205677 1.0000360 1.1813942 0.6259329 0.7588780    ## case when dim(Xs) > dim(Zs) g1 <-gencal(Xs = stats::model.matrix(~ x1 + x2, data = sample),             Zs = stats::model.matrix(~ y, data = sample),             d = sample$d,             pop_totals = totals,             method = \"raking\",             eps = .Machine$double.eps,             maxit = 100,             tol = 1e-8)  head(g1) #display only couple of first output values #> [1] 0.9848552 1.3473675 0.9738708 1.0238946 0.8732709 0.9509450"},{"path":"https://maciejostapiuk.github.io/MNAR/reference/mnar.html","id":null,"dir":"Reference","previous_headings":"","what":"The main function for the not missing at random non-response — mnar","title":"The main function for the not missing at random non-response — mnar","text":"part description go","code":""},{"path":"https://maciejostapiuk.github.io/MNAR/reference/mnar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The main function for the not missing at random non-response — mnar","text":"","code":"mnar(   response,   outcome,   calibration,   target,   data,   svydesign,   dweights,   N,   pop_totals,   method = c(\"gencalib\", \"emplik\", \"gmm\"),   tol = 1e-08,   maxit = 100,   eps = .Machine$double.eps,   control = NULL,   ... )"},{"path":"https://maciejostapiuk.github.io/MNAR/reference/mnar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The main function for the not missing at random non-response — mnar","text":"response response variables (instruments) outcome outcome variables (modelling E(Y|X)) calibration calibration variables (totals reproduced) target target variable data data.frame svydesign surveydesign object dweights design weights N population size pop_totals population totals (calibration response) method methods c(\"gencalib\", \"emplik\", \"gmm\") tol tolerance 1e-8 maxit maxit 50 eps eps inverse .Machine$double.eps control control methods ... TBA","code":""},{"path":"https://maciejostapiuk.github.io/MNAR/reference/mnar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The main function for the not missing at random non-response — mnar","text":"Returns list containing: g – g-weight sums sample size, Xs – matrix used calibration (.e. Intercept, X X_q transformed calibration quantiles), totals – vector totals (.e. N, pop_totals pop_quantiles), method – selected method, backend – selected backend.","code":""},{"path":"https://maciejostapiuk.github.io/MNAR/reference/mnar.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The main function for the not missing at random non-response — mnar","text":"Imports function","code":""},{"path":"https://maciejostapiuk.github.io/MNAR/reference/mnar.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The main function for the not missing at random non-response — mnar","text":"Andridge, Rebecca R, Roderick JA Little. 2011. “Proxy Pattern-Mixture Analysis Survey Nonresponse.” Journal Official Statistics 27 (2): 153. Chang, T., P. S. Kott. 2008. “Using Calibration Weighting Adjust Nonresponse Plausible Model.” Biometrika 95 (3): 555–71. https://doi.org/10.1093/biomet/asn022. Deville, Jean-Claude, Carl-Erik Särndal. 1992. “Calibration Estimators Survey Sampling.” Journal American Statistical Association 87 (418): 376–82. Estevao, Victor, Carl Särndal. n.d. “Functional Form Approach Calibration.” Journal ®cial Statistics 16 (4): 379±399. https://www.proquest.com/scholarly-journals/functional-form-approach-calibration/docview/1266846662/se-2. Isaki, C. T., W. . Fuller. 1982. “Survey Design Regression Super-Population Model.” Journal American Statistical Association 77 (377): 89–96. Kott, Phillip S., Ted Chang. 2010. “Using Calibration Weighting Adjust Nonignorable Unit Nonresponse.” Journal American Statistical Association 105 (491): 1265–75. https://doi.org/10.1198/jasa.2010.tm09016. Kott, Phillip S., Dan Liao. 2017. “Calibration Weighting Nonresponse Missing Random: Allowing Calibration Response-Model Variables.” Journal Survey Statistics Methodology 5 (2): 159–74. https://doi.org/10.1093/jssam/smx003. add others","code":""},{"path":[]},{"path":"https://maciejostapiuk.github.io/MNAR/reference/mnar.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"The main function for the not missing at random non-response — mnar","text":"Maciej Ostapiuk, Maciej Beręsewicz","code":""},{"path":"https://maciejostapiuk.github.io/MNAR/reference/mnar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The main function for the not missing at random non-response — mnar","text":"","code":"# Set seed for reproducibility set.seed(123)  # Define sample size n <- 10000  # Generate variables x1 <- rlnorm(n, 0, 1) x2 <- rexp(n, 1) x3 <-  rpois(n,2) y <- 1 + x1 + x2 + rnorm(n)  # Calculate probabilities pr <- plogis(1 + 0.5*x1 - 0.5*y)  # Create population data frame pop_data <- data.frame(x1, x2, y, pr)  # Calculate population totals totals <- c(N = n, colSums(pop_data[, c(\"x1\", \"x2\", \"y\")]))  # Generate flag variable based on probabilities flag <- rbinom(n, 1, pop_data$pr)  # Create sample based on flag sample <- pop_data[flag == 1, ] sample$d <- n/nrow(sample)   # Case when dim(response) == dim(calibration) g <- mnar(response = ~ x1 + y,             calibration =  ~ x1 + x2,             data = sample, dweights = sample$d,             pop_totals = totals,             method = \"gencalib\")  head(g) #display only couple of first output values #> [1] 1.1800080 2.6205677 1.0000360 1.1813942 0.6259329 0.7588780  ## Case when dim(response) < dim(calibration) g1 <- mnar(response = ~ y,              calibration =  ~ x1 + x2,              data = sample, dweights = sample$d,              pop_totals = totals,              method = \"gencalib\")  head(g1) #display only couple of first output values #> [1] 0.9848552 1.3473675 0.9738708 1.0238946 0.8732709 0.9509450"}]
